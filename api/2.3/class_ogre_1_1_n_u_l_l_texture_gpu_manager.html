<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Ogre::NULLTextureGpuManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE<span id="projectnumber">&#160;2.3</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_ogre_1_1_n_u_l_l_texture_gpu_manager.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_ogre_1_1_n_u_l_l_texture_gpu_manager-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ogre::NULLTextureGpuManager Class Reference<div class="ingroups"><a class="el" href="group___core.html">Core</a> &raquo; <a class="el" href="group___resources.html">Resources</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;OgreNULLTextureGpuManager.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::NULLTextureGpuManager:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_n_u_l_l_texture_gpu_manager__inherit__graph.svg" width="312" height="187"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a243112239378b673ba9f1df5e7abdbf3"><td class="memItemLeft" align="right" valign="top">typedef vector&lt; <a class="el" href="struct_ogre_1_1_texture_gpu_manager_1_1_budget_entry.html">BudgetEntry</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a243112239378b673ba9f1df5e7abdbf3">BudgetEntryVec</a></td></tr>
<tr class="separator:a243112239378b673ba9f1df5e7abdbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e42d75a1eae1a28e52e4613832edb3"><td class="memItemLeft" align="right" valign="top">typedef map&lt; <a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>, <a class="el" href="struct_ogre_1_1_texture_gpu_manager_1_1_metadata_cache_entry.html">MetadataCacheEntry</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a75e42d75a1eae1a28e52e4613832edb3">MetadataCacheMap</a></td></tr>
<tr class="separator:a75e42d75a1eae1a28e52e4613832edb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe11bd546cf7315f4526488e7078cc7d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7d">Reason</a> { <br />
&#160;&#160;<a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7da2b732a317de0915527e291485ca42e82">Unknown</a>
, <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7da58fd07194714679ed3ba9857d7656f27">FromStorageToSysRam</a>
, <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7da058c0eecb9f3f188fccc4d0018bf337b">FromSysRamToStorage</a>
, <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7da55066351a26967068b944c2170e51af1">GainedResidency</a>
, <br />
&#160;&#160;<a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7da61729c4ae25807d6132d5bc46580ff3d">LostResidency</a>
, <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7dafbdd85981846de4423d48d1a0ff665e0">PoolTextureSlotChanged</a>
, <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7da218a4243be85ec9c989b777119d5ff47">ResidentToSysRamSync</a>
, <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7da4f559ca1853a24a28b40caae1acda604">MetadataCacheOutOfDate</a>
, <br />
&#160;&#160;<a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7da704ea118c7e9f0b1598b528bdcbe1b26">ExceptionThrown</a>
, <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7dae3eb70053cbf5401f22893cdb47f81a7">FsaaSettingAlteredByApi</a>
, <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7dad4d9c6e3b7755f38d8d5f003be100257">ReadyForRendering</a>
, <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7dabb2a61a0002ccca6afbde7588787e58e">Deleted</a>
<br />
 }</td></tr>
<tr class="separator:afe11bd546cf7315f4526488e7078cc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad657330e7020f561860d24366460271c"><td class="memItemLeft" align="right" valign="top">typedef map&lt; <a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>, <a class="el" href="struct_ogre_1_1_texture_gpu_manager_1_1_resource_entry.html">ResourceEntry</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#ad657330e7020f561860d24366460271c">ResourceEntryMap</a></td></tr>
<tr class="separator:ad657330e7020f561860d24366460271c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3b2eb464f34ca01c6e0f60b3a7e837cf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_n_u_l_l_texture_gpu_manager.html#a3b2eb464f34ca01c6e0f60b3a7e837cf">NULLTextureGpuManager</a> (<a class="el" href="class_ogre_1_1_vao_manager.html">VaoManager</a> *vaoManager, <a class="el" href="class_ogre_1_1_render_system.html">RenderSystem</a> *renderSystem)</td></tr>
<tr class="separator:a3b2eb464f34ca01c6e0f60b3a7e837cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04254d4d0ac0721302bff73389f19116"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_n_u_l_l_texture_gpu_manager.html#a04254d4d0ac0721302bff73389f19116">~NULLTextureGpuManager</a> ()</td></tr>
<tr class="separator:a04254d4d0ac0721302bff73389f19116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68dec5d2c3187c3d7be56d9c5cc55fc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a68dec5d2c3187c3d7be56d9c5cc55fc4">_queueDownloadToRam</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture, bool resyncOnly)</td></tr>
<tr class="separator:a68dec5d2c3187c3d7be56d9c5cc55fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a4bb400a24d0e3ea9a9299192fa51d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a89a4bb400a24d0e3ea9a9299192fa51d">_releaseSlotFromTexture</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture)</td></tr>
<tr class="memdesc:a89a4bb400a24d0e3ea9a9299192fa51d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Must be called from main thread.  <a href="class_ogre_1_1_texture_gpu_manager.html#a89a4bb400a24d0e3ea9a9299192fa51d">More...</a><br /></td></tr>
<tr class="separator:a89a4bb400a24d0e3ea9a9299192fa51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a3edb2437dae48c14a0d20c50877fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a38a3edb2437dae48c14a0d20c50877fa">_removeMetadataCacheEntry</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture)</td></tr>
<tr class="separator:a38a3edb2437dae48c14a0d20c50877fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93773f33d6018c991b4fa8c475a8a36d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a93773f33d6018c991b4fa8c475a8a36d">_reserveSlotForTexture</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture)</td></tr>
<tr class="memdesc:a93773f33d6018c991b4fa8c475a8a36d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Must be called from main thread.  <a href="class_ogre_1_1_texture_gpu_manager.html#a93773f33d6018c991b4fa8c475a8a36d">More...</a><br /></td></tr>
<tr class="separator:a93773f33d6018c991b4fa8c475a8a36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435b32507353f22b8428e6f9d849e7e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a435b32507353f22b8428e6f9d849e7e1">_scheduleTransitionTo</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture, <a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a> targetResidency, <a class="el" href="class_ogre_1_1_image2.html">Image2</a> *image, bool autoDeleteImage, bool reuploadOnly)</td></tr>
<tr class="separator:a435b32507353f22b8428e6f9d849e7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f6c11e4af75070ada1e868e7b24412"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a46f6c11e4af75070ada1e868e7b24412">_scheduleUpdate</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> filters, <a class="el" href="class_ogre_1_1_image2.html">Image2</a> *image, bool autoDeleteImage, bool skipMetadataCache=false, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> sliceOrDepth=std::numeric_limits&lt; <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> &gt;::max())</td></tr>
<tr class="separator:a46f6c11e4af75070ada1e868e7b24412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae905930e6b79e3a3c3152efc20d5249c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#ae905930e6b79e3a3c3152efc20d5249c">_setIgnoreScheduledTasks</a> (bool ignoreSchedTasks)</td></tr>
<tr class="memdesc:ae905930e6b79e3a3c3152efc20d5249c"><td class="mdescLeft">&#160;</td><td class="mdescRight">When true we will ignore all tasks in mScheduledTasks and execute transitions immediately Caller is responsible for ensuring this is safe to do.  <a href="class_ogre_1_1_texture_gpu_manager.html#ae905930e6b79e3a3c3152efc20d5249c">More...</a><br /></td></tr>
<tr class="separator:ae905930e6b79e3a3c3152efc20d5249c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa961b3aafc08805f7611d4edd283f804"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#aa961b3aafc08805f7611d4edd283f804">_update</a> (bool syncWithWorkerThread)</td></tr>
<tr class="memdesc:aa961b3aafc08805f7611d4edd283f804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there is no more streaming work to be done yet (if false, calls to _update could be needed once again) See waitForStreamingCompletion.  <a href="class_ogre_1_1_texture_gpu_manager.html#aa961b3aafc08805f7611d4edd283f804">More...</a><br /></td></tr>
<tr class="separator:aa961b3aafc08805f7611d4edd283f804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6d7560d59263dc303563777b5c61e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a4f6d7560d59263dc303563777b5c61e8">_updateMetadataCache</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture)</td></tr>
<tr class="separator:a4f6d7560d59263dc303563777b5c61e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3f9567c396b28a1f73a7044d9957bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#aec3f9567c396b28a1f73a7044d9957bd">_updateStreaming</a> (void)</td></tr>
<tr class="separator:aec3f9567c396b28a1f73a7044d9957bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6ee50fe51ac71c60f66e044859bf9d"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a4f6ee50fe51ac71c60f66e044859bf9d">_updateStreamingWorkerThread</a> (<a class="el" href="class_ogre_1_1_thread_handle.html">ThreadHandle</a> *threadHandle)</td></tr>
<tr class="separator:a4f6ee50fe51ac71c60f66e044859bf9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c872d542fd78e2db884ff8904d4c39d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a2c872d542fd78e2db884ff8904d4c39d">_waitFor</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture, bool metadataOnly)</td></tr>
<tr class="memdesc:a2c872d542fd78e2db884ff8904d4c39d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not use directly. See <a class="el" href="class_ogre_1_1_texture_gpu.html#a6740006ae83f39c4aeb83f300b67f6b2" title="Blocks main thread until metadata is ready.">TextureGpu::waitForMetadata</a> &amp; TextureGpu::waitForDataReady.  <a href="class_ogre_1_1_texture_gpu_manager.html#a2c872d542fd78e2db884ff8904d4c39d">More...</a><br /></td></tr>
<tr class="separator:a2c872d542fd78e2db884ff8904d4c39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55e0672860ad3ed3695374d9e12c7ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#ac55e0672860ad3ed3695374d9e12c7ba">_waitForPendingGpuToCpuSyncs</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture)</td></tr>
<tr class="memdesc:ac55e0672860ad3ed3695374d9e12c7ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not use directly. See TextureGpu::waitForPendingSyncs.  <a href="class_ogre_1_1_texture_gpu_manager.html#ac55e0672860ad3ed3695374d9e12c7ba">More...</a><br /></td></tr>
<tr class="separator:ac55e0672860ad3ed3695374d9e12c7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4cace3a36dcc63cb0ba5662f2c29b8a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#ae4cace3a36dcc63cb0ba5662f2c29b8a">checkSupport</a> (<a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> format, <a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a> textureType, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> textureFlags) const</td></tr>
<tr class="memdesc:ae4cace3a36dcc63cb0ba5662f2c29b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given format with the texture flags combination is supported.  <a href="class_ogre_1_1_texture_gpu_manager.html#ae4cace3a36dcc63cb0ba5662f2c29b8a">More...</a><br /></td></tr>
<tr class="separator:ae4cace3a36dcc63cb0ba5662f2c29b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e7ae62f823f48c7c4844a2d34589de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_async_texture_ticket.html">AsyncTextureTicket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a71e7ae62f823f48c7c4844a2d34589de">createAsyncTextureTicket</a> (<a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> width, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> height, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> depthOrSlices, <a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a> textureType, <a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> pixelFormatFamily)</td></tr>
<tr class="memdesc:a71e7ae62f823f48c7c4844a2d34589de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="class_ogre_1_1_async_texture_ticket.html" title="In Ogre 2.2 reading data from GPU back to CPU is asynchronous.">AsyncTextureTicket</a> that can be used to download data GPU -&gt; CPU from a <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a>.  <a href="class_ogre_1_1_texture_gpu_manager.html#a71e7ae62f823f48c7c4844a2d34589de">More...</a><br /></td></tr>
<tr class="separator:a71e7ae62f823f48c7c4844a2d34589de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad118a876e3102b5ae6ba5cefba5bdf1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#ad118a876e3102b5ae6ba5cefba5bdf1d">createOrRetrieveTexture</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;aliasName, <a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a> pageOutStrategy, <a class="el" href="namespace_ogre_1_1_common_texture_types.html#a3a978c834ce00930123468c9a64047b4">CommonTextureTypes::CommonTextureTypes</a> type, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;resourceGroup=<a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a>, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> poolId=0)</td></tr>
<tr class="memdesc:ad118a876e3102b5ae6ba5cefba5bdf1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to call createOrRetrieveTexture with common parameters used for 2D diffuse textures loaded from file.  <a href="class_ogre_1_1_texture_gpu_manager.html#ad118a876e3102b5ae6ba5cefba5bdf1d">More...</a><br /></td></tr>
<tr class="separator:ad118a876e3102b5ae6ba5cefba5bdf1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f8cd49c0990fb532306a1569b58f33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a24f8cd49c0990fb532306a1569b58f33">createOrRetrieveTexture</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;aliasName, <a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a> pageOutStrategy, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> textureFlags, <a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a> initialType, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;resourceGroup=<a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a>, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> filters=0, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> poolId=0)</td></tr>
<tr class="separator:a24f8cd49c0990fb532306a1569b58f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5643e2d490f3f305828e3de64e1b5934"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a5643e2d490f3f305828e3de64e1b5934">createOrRetrieveTexture</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, <a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a> pageOutStrategy, <a class="el" href="namespace_ogre_1_1_common_texture_types.html#a3a978c834ce00930123468c9a64047b4">CommonTextureTypes::CommonTextureTypes</a> type, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;resourceGroup=<a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a>, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> poolId=0)</td></tr>
<tr class="separator:a5643e2d490f3f305828e3de64e1b5934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf67202da75b8c6f9134d7e81baa89d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#abf67202da75b8c6f9134d7e81baa89d8">createOrRetrieveTexture</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, <a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a> pageOutStrategy, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> textureFlags, <a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a> initialType, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;resourceGroup=<a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a>, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> filters=0, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> poolId=0)</td></tr>
<tr class="separator:abf67202da75b8c6f9134d7e81baa89d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017eec4324d75ffb0de6b0fc1fdd2654"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a017eec4324d75ffb0de6b0fc1fdd2654">createTexture</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;aliasName, <a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a> pageOutStrategy, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> textureFlags, <a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a> initialType, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;resourceGroup=<a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a>, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> filters=0, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> poolId=0)</td></tr>
<tr class="separator:a017eec4324d75ffb0de6b0fc1fdd2654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1cdf54c1a262bc911d37235682ec1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a8d1cdf54c1a262bc911d37235682ec1c">createTexture</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, <a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a> pageOutStrategy, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> textureFlags, <a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a> initialType, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;resourceGroup=<a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a>, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> filters=0, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> poolId=0)</td></tr>
<tr class="separator:a8d1cdf54c1a262bc911d37235682ec1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93bc76576f34bab1470f094537dbce56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_n_u_l_l_texture_gpu_manager.html#a93bc76576f34bab1470f094537dbce56">createTextureGpuWindow</a> (void)</td></tr>
<tr class="separator:a93bc76576f34bab1470f094537dbce56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02832e2789d8fc68b4ce4586bad25010"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a02832e2789d8fc68b4ce4586bad25010">destroyAllAsyncTextureTicket</a> (void)</td></tr>
<tr class="separator:a02832e2789d8fc68b4ce4586bad25010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af906e6a5e055170b281a1986374b4754"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#af906e6a5e055170b281a1986374b4754">destroyAsyncTextureTicket</a> (<a class="el" href="class_ogre_1_1_async_texture_ticket.html">AsyncTextureTicket</a> *ticket)</td></tr>
<tr class="separator:af906e6a5e055170b281a1986374b4754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc898578da3113affb78ed60f209b71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a7dc898578da3113affb78ed60f209b71">destroyTexture</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture)</td></tr>
<tr class="memdesc:a7dc898578da3113affb78ed60f209b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a texture.  <a href="class_ogre_1_1_texture_gpu_manager.html#a7dc898578da3113affb78ed60f209b71">More...</a><br /></td></tr>
<tr class="separator:a7dc898578da3113affb78ed60f209b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841f10a656bbd24ed92b87f616e33f74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a841f10a656bbd24ed92b87f616e33f74">dumpMemoryUsage</a> (<a class="el" href="class_ogre_1_1_log.html">Log</a> *log, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">Ogre::uint32</a> mask=<a class="el" href="namespace_ogre_1_1_residency_mask.html#a41a75eb215f69beb19a0039eb7e2b141a98b6ac43f7a59e7ed0b61a1b529f06ca">ResidencyMask::All</a>) const</td></tr>
<tr class="separator:a841f10a656bbd24ed92b87f616e33f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0ab5ff277943748df853653efb8913"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a0b0ab5ff277943748df853653efb8913">dumpStats</a> (void) const</td></tr>
<tr class="separator:a0b0ab5ff277943748df853653efb8913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400906a91ef0c5b7b61329de7872c91e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a400906a91ef0c5b7b61329de7872c91e">executeTask</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture, <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7d">TextureGpuListener::Reason</a> reason, const ScheduledTasks &amp;task)</td></tr>
<tr class="separator:a400906a91ef0c5b7b61329de7872c91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ea160f5cd58eb1569743dee3bff9cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a25ea160f5cd58eb1569743dee3bff9cc">exportTextureMetadataCache</a> (<a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;outJson)</td></tr>
<tr class="separator:a25ea160f5cd58eb1569743dee3bff9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7dedc19c2251a15643a3e240225abd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#abf7dedc19c2251a15643a3e240225abd">findAliasNameStr</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> idName) const</td></tr>
<tr class="memdesc:abf7dedc19c2251a15643a3e240225abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function CAN be called from any thread.  <a href="class_ogre_1_1_texture_gpu_manager.html#abf7dedc19c2251a15643a3e240225abd">More...</a><br /></td></tr>
<tr class="separator:abf7dedc19c2251a15643a3e240225abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7a7a36c00587fb8298f4100606c627"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#abf7a7a36c00587fb8298f4100606c627">findResourceGroupStr</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> idName) const</td></tr>
<tr class="memdesc:abf7a7a36c00587fb8298f4100606c627"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function CAN be called from any thread.  <a href="class_ogre_1_1_texture_gpu_manager.html#abf7a7a36c00587fb8298f4100606c627">More...</a><br /></td></tr>
<tr class="separator:abf7a7a36c00587fb8298f4100606c627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45819a2f57371a1d5ae1d026a21510ab"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a45819a2f57371a1d5ae1d026a21510ab">findResourceNameStr</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> idName) const</td></tr>
<tr class="memdesc:a45819a2f57371a1d5ae1d026a21510ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function CAN be called from any thread.  <a href="class_ogre_1_1_texture_gpu_manager.html#a45819a2f57371a1d5ae1d026a21510ab">More...</a><br /></td></tr>
<tr class="separator:a45819a2f57371a1d5ae1d026a21510ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7aa5c6af459eb788ed985104c21f5f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#ad7aa5c6af459eb788ed985104c21f5f7">findTextureNoThrow</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> name) const</td></tr>
<tr class="separator:ad7aa5c6af459eb788ed985104c21f5f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e938ff8fcf2cf1312e916b3b5078cfe"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a243112239378b673ba9f1df5e7abdbf3">BudgetEntryVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a5e938ff8fcf2cf1312e916b3b5078cfe">getBudget</a> (void) const</td></tr>
<tr class="separator:a5e938ff8fcf2cf1312e916b3b5078cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34d0779d8e031e998915b4528dbddb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre_1_1_default_mipmap_gen.html#a3eb99f91a07b98f3713bf8c23069e9fb">DefaultMipmapGen::DefaultMipmapGen</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#af34d0779d8e031e998915b4528dbddb6">getDefaultMipmapGeneration</a> (void) const</td></tr>
<tr class="separator:af34d0779d8e031e998915b4528dbddb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace14aaadb7bf3b43b564c218186df62d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre_1_1_default_mipmap_gen.html#a3eb99f91a07b98f3713bf8c23069e9fb">DefaultMipmapGen::DefaultMipmapGen</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#ace14aaadb7bf3b43b564c218186df62d">getDefaultMipmapGenerationCubemaps</a> (void) const</td></tr>
<tr class="separator:ace14aaadb7bf3b43b564c218186df62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7806f6c350ad71d918f75a99fca84f0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#ad657330e7020f561860d24366460271c">ResourceEntryMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#ab7806f6c350ad71d918f75a99fca84f0">getEntries</a> (void) const</td></tr>
<tr class="separator:ab7806f6c350ad71d918f75a99fca84f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9374e0a6a80f16ef5b3e95f38c2e44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a00f119d555e251922c695ec569ccfd95">uint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a0e9374e0a6a80f16ef5b3e95f38c2e44">getLoadRequestsCounter</a> () const</td></tr>
<tr class="memdesc:a0e9374e0a6a80f16ef5b3e95f38c2e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calling waitForStreamingCompletion before <a class="el" href="class_ogre_1_1_root.html#aeaad25268c0ad8007ce8961a32242c77" title="Render one frame.">Root::renderOneFrame</a> should guarantee the render is perfect.  <a href="class_ogre_1_1_texture_gpu_manager.html#a0e9374e0a6a80f16ef5b3e95f38c2e44">More...</a><br /></td></tr>
<tr class="separator:a0e9374e0a6a80f16ef5b3e95f38c2e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3886c70b1674b192547c407edeb4c67e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a3886c70b1674b192547c407edeb4c67e">getMemoryStats</a> (size_t &amp;outTextureBytesCpu, size_t &amp;outTextureBytesGpu, size_t &amp;outUsedStagingTextureBytes, size_t &amp;outAvailableStagingTextureBytes)</td></tr>
<tr class="separator:a3886c70b1674b192547c407edeb4c67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f2c6ee08fce32295e93904e94d69fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_render_system.html">RenderSystem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#ad9f2c6ee08fce32295e93904e94d69fb">getRenderSystem</a> (void) const</td></tr>
<tr class="separator:ad9f2c6ee08fce32295e93904e94d69fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f2ab9f38f0dbf29a75a82030231a9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_staging_texture.html">StagingTexture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a18f2ab9f38f0dbf29a75a82030231a9f">getStagingTexture</a> (<a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> width, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> height, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> depth, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> slices, <a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> pixelFormat, size_t minConsumptionRatioThreshold=25u)</td></tr>
<tr class="memdesc:a18f2ab9f38f0dbf29a75a82030231a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> which is required to upload data CPU -&gt; GPU into a <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a>.  <a href="class_ogre_1_1_texture_gpu_manager.html#a18f2ab9f38f0dbf29a75a82030231a9f">More...</a><br /></td></tr>
<tr class="separator:a18f2ab9f38f0dbf29a75a82030231a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7f3c063418bd31e284fd3dbd4f585e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_vao_manager.html">VaoManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a9b7f3c063418bd31e284fd3dbd4f585e">getVaoManager</a> (void) const</td></tr>
<tr class="separator:a9b7f3c063418bd31e284fd3dbd4f585e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064b32e7db16917d223a729f3ce03a96"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a064b32e7db16917d223a729f3ce03a96">hasPoolId</a> (<a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> poolId, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> width, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> height, <a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> numMipmaps, <a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> pixelFormat) const</td></tr>
<tr class="separator:a064b32e7db16917d223a729f3ce03a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7152f97e84cd44d73afc86d77951120"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#ae7152f97e84cd44d73afc86d77951120">hasTextureResource</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;aliasName, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;resourceGroup) const</td></tr>
<tr class="memdesc:ae7152f97e84cd44d73afc86d77951120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a texture with the given aliasName exists, or if a <a class="el" href="class_ogre_1_1_resource_group_listener.html" title="This abstract class defines an interface which is called back during resource group loading to indica...">ResourceGroupListener</a> provides such texture, or if such texture exists (i.e.  <a href="class_ogre_1_1_texture_gpu_manager.html#ae7152f97e84cd44d73afc86d77951120">More...</a><br /></td></tr>
<tr class="separator:ae7152f97e84cd44d73afc86d77951120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423e53613f85ab74171ac4bb291c2555"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a423e53613f85ab74171ac4bb291c2555">importTextureMetadataCache</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;filename, const char *jsonString, bool bCreateReservedPools)</td></tr>
<tr class="separator:a423e53613f85ab74171ac4bb291c2555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2d1de6d372585cc4acfa16abae331c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#aad2d1de6d372585cc4acfa16abae331c">isDoneStreaming</a> (void) const</td></tr>
<tr class="memdesc:aad2d1de6d372585cc4acfa16abae331c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if we're done loading all textures based on the return value of the last call to <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#aa961b3aafc08805f7611d4edd283f804" title="Returns true if there is no more streaming work to be done yet (if false, calls to _update could be n...">TextureGpuManager::_update</a> and whether new tasks have been scheduled since then.  <a href="class_ogre_1_1_texture_gpu_manager.html#aad2d1de6d372585cc4acfa16abae331c">More...</a><br /></td></tr>
<tr class="separator:aad2d1de6d372585cc4acfa16abae331c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2012775609f389c5f205ee089a0c8b8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#ab2012775609f389c5f205ee089a0c8b8">notifyTextureChanged</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture, <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7d">TextureGpuListener::Reason</a> reason, void *extraData)</td></tr>
<tr class="separator:ab2012775609f389c5f205ee089a0c8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8357fe4fb4849772b94baa4bf47c7ded"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a8357fe4fb4849772b94baa4bf47c7ded">operator delete</a> (void *ptr)</td></tr>
<tr class="separator:a8357fe4fb4849772b94baa4bf47c7ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb46d4b0a597156d9ba5abc39d127792"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#acb46d4b0a597156d9ba5abc39d127792">operator delete</a> (void *ptr, const char *, int, const char *)</td></tr>
<tr class="separator:acb46d4b0a597156d9ba5abc39d127792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c727e879a260c37b00ce5505fe8e144"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a1c727e879a260c37b00ce5505fe8e144">operator delete</a> (void *ptr, void *)</td></tr>
<tr class="separator:a1c727e879a260c37b00ce5505fe8e144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e6a86dde5483c053ca0f2a85bbfd6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a93e6a86dde5483c053ca0f2a85bbfd6c">operator delete[]</a> (void *ptr)</td></tr>
<tr class="separator:a93e6a86dde5483c053ca0f2a85bbfd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595ea4c05da8aa987d3800e65d23355d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a595ea4c05da8aa987d3800e65d23355d">operator delete[]</a> (void *ptr, const char *, int, const char *)</td></tr>
<tr class="separator:a595ea4c05da8aa987d3800e65d23355d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f1a983f9e2dfddee802c47bb0b1ca9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#ad1f1a983f9e2dfddee802c47bb0b1ca9">operator new</a> (size_t sz)</td></tr>
<tr class="separator:ad1f1a983f9e2dfddee802c47bb0b1ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab422c67a2c8844f410fe822a357cba3b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#ab422c67a2c8844f410fe822a357cba3b">operator new</a> (size_t sz, const char *file, int line, const char *func)</td></tr>
<tr class="memdesc:ab422c67a2c8844f410fe822a357cba3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator new, with debug line info  <a href="class_ogre_1_1_allocated_object.html#ab422c67a2c8844f410fe822a357cba3b">More...</a><br /></td></tr>
<tr class="separator:ab422c67a2c8844f410fe822a357cba3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63fc6bdc2eb6aeac24898a77ec5e2023"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a63fc6bdc2eb6aeac24898a77ec5e2023">operator new</a> (size_t sz, void *ptr)</td></tr>
<tr class="memdesc:a63fc6bdc2eb6aeac24898a77ec5e2023"><td class="mdescLeft">&#160;</td><td class="mdescRight">placement operator new  <a href="class_ogre_1_1_allocated_object.html#a63fc6bdc2eb6aeac24898a77ec5e2023">More...</a><br /></td></tr>
<tr class="separator:a63fc6bdc2eb6aeac24898a77ec5e2023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce32528577d71b228692df906ecd17c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#adce32528577d71b228692df906ecd17c">operator new[]</a> (size_t sz)</td></tr>
<tr class="separator:adce32528577d71b228692df906ecd17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1464ac3de21ff20db8f9f1f8608dc7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#aed1464ac3de21ff20db8f9f1f8608dc7">operator new[]</a> (size_t sz, const char *file, int line, const char *func)</td></tr>
<tr class="memdesc:aed1464ac3de21ff20db8f9f1f8608dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">array operator new, with debug line info  <a href="class_ogre_1_1_allocated_object.html#aed1464ac3de21ff20db8f9f1f8608dc7">More...</a><br /></td></tr>
<tr class="separator:aed1464ac3de21ff20db8f9f1f8608dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614a8c355b86c01d9f7b847b670c1cd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a614a8c355b86c01d9f7b847b670c1cd3">removeStagingTexture</a> (<a class="el" href="class_ogre_1_1_staging_texture.html">StagingTexture</a> *stagingTexture)</td></tr>
<tr class="separator:a614a8c355b86c01d9f7b847b670c1cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e96132817c27bfae1c0374e98d20dfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a6e96132817c27bfae1c0374e98d20dfc">reservePoolId</a> (<a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> poolId, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> width, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> height, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> numSlices, <a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> numMipmaps, <a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a> pixelFormat)</td></tr>
<tr class="memdesc:a6e96132817c27bfae1c0374e98d20dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves and preallocates a pool with the given parameters Returns the master texture that owns the pool.  <a href="class_ogre_1_1_texture_gpu_manager.html#a6e96132817c27bfae1c0374e98d20dfc">More...</a><br /></td></tr>
<tr class="separator:a6e96132817c27bfae1c0374e98d20dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3796bc1de6a5a6efc208620686982b54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a3796bc1de6a5a6efc208620686982b54">saveTexture</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;folderPath, set&lt; <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &gt;::type &amp;savedTextures, bool saveOitd, bool saveOriginal, <a class="el" href="class_ogre_1_1_hlms_texture_export_listener.html">HlmsTextureExportListener</a> *listener)</td></tr>
<tr class="separator:a3796bc1de6a5a6efc208620686982b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe21fe76416e68bcfc8fe57f2655e868"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#abe21fe76416e68bcfc8fe57f2655e868">setDefaultMipmapGeneration</a> (<a class="el" href="namespace_ogre_1_1_default_mipmap_gen.html#a3eb99f91a07b98f3713bf8c23069e9fb">DefaultMipmapGen::DefaultMipmapGen</a> defaultMipmapGen, <a class="el" href="namespace_ogre_1_1_default_mipmap_gen.html#a3eb99f91a07b98f3713bf8c23069e9fb">DefaultMipmapGen::DefaultMipmapGen</a> defaultMipmapGenCubemaps)</td></tr>
<tr class="memdesc:abe21fe76416e68bcfc8fe57f2655e868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether to use HW or SW mipmap generation when specifying <a class="el" href="namespace_ogre_1_1_texture_filter.html#ad1f488159fb867da13bf2ae96f04b054a537f83d75be40b8f38b5f9dc03912afa">TextureFilter::TypeGenerateDefaultMipmaps</a> for loading files from textures.  <a href="class_ogre_1_1_texture_gpu_manager.html#abe21fe76416e68bcfc8fe57f2655e868">More...</a><br /></td></tr>
<tr class="separator:abe21fe76416e68bcfc8fe57f2655e868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164a5285771064ccd10c8c2d9392d9da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a164a5285771064ccd10c8c2d9392d9da">setStagingTextureMaxBudgetBytes</a> (size_t stagingTextureMaxBudgetBytes)</td></tr>
<tr class="memdesc:a164a5285771064ccd10c8c2d9392d9da"><td class="mdescLeft">&#160;</td><td class="mdescRight">At a high level, texture loading works like this:  <a href="class_ogre_1_1_texture_gpu_manager.html#a164a5285771064ccd10c8c2d9392d9da">More...</a><br /></td></tr>
<tr class="separator:a164a5285771064ccd10c8c2d9392d9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68751724984a25c311ca98459a739aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#af68751724984a25c311ca98459a739aa">setTextureGpuManagerListener</a> (<a class="el" href="class_ogre_1_1_texture_gpu_manager_listener.html">TextureGpuManagerListener</a> *listener)</td></tr>
<tr class="memdesc:af68751724984a25c311ca98459a739aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a new listener.  <a href="class_ogre_1_1_texture_gpu_manager.html#af68751724984a25c311ca98459a739aa">More...</a><br /></td></tr>
<tr class="separator:af68751724984a25c311ca98459a739aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763c9420839cf914f7a5c1901c53539b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a763c9420839cf914f7a5c1901c53539b">setTrylockMutexFailureLimit</a> (<a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> tryLockFailureLimit)</td></tr>
<tr class="memdesc:a763c9420839cf914f7a5c1901c53539b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main thread tries to acquire a lock from the background thread, do something very quick, and release it.  <a href="class_ogre_1_1_texture_gpu_manager.html#a763c9420839cf914f7a5c1901c53539b">More...</a><br /></td></tr>
<tr class="separator:a763c9420839cf914f7a5c1901c53539b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb00a770d365459f490c2ecd9b96f025"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#aeb00a770d365459f490c2ecd9b96f025">setWorkerThreadMaxPerStagingTextureRequestBytes</a> (size_t maxPerStagingTextureRequestBytes)</td></tr>
<tr class="memdesc:aeb00a770d365459f490c2ecd9b96f025"><td class="mdescLeft">&#160;</td><td class="mdescRight">The worker thread tracks how many data it is loading so the Main thread can request additional StagingTextures if necessary.  <a href="class_ogre_1_1_texture_gpu_manager.html#aeb00a770d365459f490c2ecd9b96f025">More...</a><br /></td></tr>
<tr class="separator:aeb00a770d365459f490c2ecd9b96f025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de9d156bb0ef5a625f0f8a6f08a9b19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a6de9d156bb0ef5a625f0f8a6f08a9b19">setWorkerThreadMaxPreloadBytes</a> (size_t maxPreloadBytes)</td></tr>
<tr class="memdesc:a6de9d156bb0ef5a625f0f8a6f08a9b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">The worker thread first loads the texture from disk to RAM (aka "preload", and then copies from RAM to <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a>.  <a href="class_ogre_1_1_texture_gpu_manager.html#a6de9d156bb0ef5a625f0f8a6f08a9b19">More...</a><br /></td></tr>
<tr class="separator:a6de9d156bb0ef5a625f0f8a6f08a9b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9065d7ce750a69d07f0d315d623b2cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#ab9065d7ce750a69d07f0d315d623b2cc">setWorkerThreadMinimumBudget</a> (const <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a243112239378b673ba9f1df5e7abdbf3">BudgetEntryVec</a> &amp;budget, size_t maxSplitResolution=0)</td></tr>
<tr class="memdesc:ab9065d7ce750a69d07f0d315d623b2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Background streaming works by having a bunch of preallocated StagingTextures so we're ready to start uploading as soon as we see a request to load a texture from file.  <a href="class_ogre_1_1_texture_gpu_manager.html#ab9065d7ce750a69d07f0d315d623b2cc">More...</a><br /></td></tr>
<tr class="separator:ab9065d7ce750a69d07f0d315d623b2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1427f0b635a4186cd6083a9bab879fa2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_listener.html#a1427f0b635a4186cd6083a9bab879fa2">shouldStayLoaded</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture)</td></tr>
<tr class="memdesc:a1427f0b635a4186cd6083a9bab879fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> should likely stay loaded or else graphical changes could occur.  <a href="class_ogre_1_1_texture_gpu_listener.html#a1427f0b635a4186cd6083a9bab879fa2">More...</a><br /></td></tr>
<tr class="separator:a1427f0b635a4186cd6083a9bab879fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1188e251546ab3391ef646d60f2317d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a1188e251546ab3391ef646d60f2317d8">shutdown</a> ()</td></tr>
<tr class="separator:a1188e251546ab3391ef646d60f2317d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0beb6964d2f52e28e852666257a30514"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a0beb6964d2f52e28e852666257a30514">taskLoadToSysRamOrResident</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture, const ScheduledTasks &amp;task)</td></tr>
<tr class="memdesc:a0beb6964d2f52e28e852666257a30514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements TaskTypeResidencyTransition when doing any of the following transitions: OnStorage -&gt; Resident OnStorage -&gt; OnSystemRam OnSystemRam -&gt; Resident.  <a href="class_ogre_1_1_texture_gpu_manager.html#a0beb6964d2f52e28e852666257a30514">More...</a><br /></td></tr>
<tr class="separator:a0beb6964d2f52e28e852666257a30514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379578bf252f5fcf0c5168f0a88c2130"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a379578bf252f5fcf0c5168f0a88c2130">taskToUnloadOrDestroy</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture, const ScheduledTasks &amp;task)</td></tr>
<tr class="memdesc:a379578bf252f5fcf0c5168f0a88c2130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements TaskTypeResidencyTransition when doing any of the following transitions: Resident -&gt; OnStorage Resident -&gt; OnSystemRam OnSystemRam -&gt; OnStorage.  <a href="class_ogre_1_1_texture_gpu_manager.html#a379578bf252f5fcf0c5168f0a88c2130">More...</a><br /></td></tr>
<tr class="separator:a379578bf252f5fcf0c5168f0a88c2130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf4123dc9b7b5242acac4bc1d9eef1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#abcf4123dc9b7b5242acac4bc1d9eef1a">waitForStreamingCompletion</a> (void)</td></tr>
<tr class="memdesc:abcf4123dc9b7b5242acac4bc1d9eef1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks main thread until all pending textures are fully loaded.  <a href="class_ogre_1_1_texture_gpu_manager.html#abcf4123dc9b7b5242acac4bc1d9eef1a">More...</a><br /></td></tr>
<tr class="separator:abcf4123dc9b7b5242acac4bc1d9eef1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a1146a2b41f0f3f5d3b0b1bab1e74248d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a1146a2b41f0f3f5d3b0b1bab1e74248d">mIgnoreSRgbPreference</a></td></tr>
<tr class="memdesc:a1146a2b41f0f3f5d3b0b1bab1e74248d"><td class="mdescLeft">&#160;</td><td class="mdescRight">While true, calls to createTexture &amp; createOrRetrieveTexture will ignore and unset the <a class="el" href="namespace_ogre_1_1_texture_flags.html#a59b71e36a14465bd82595d6d467e1434aac3ff5c1bb3a3ef222a7eef0d83836ba" title="Prefer loading FROM FILES as sRGB when possible.">TextureFlags::PrefersLoadingFromFileAsSRGB</a> flag.  <a href="class_ogre_1_1_texture_gpu_manager.html#a1146a2b41f0f3f5d3b0b1bab1e74248d">More...</a><br /></td></tr>
<tr class="separator:a1146a2b41f0f3f5d3b0b1bab1e74248d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a243112239378b673ba9f1df5e7abdbf3" name="a243112239378b673ba9f1df5e7abdbf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a243112239378b673ba9f1df5e7abdbf3">&#9670;&nbsp;</a></span>BudgetEntryVec</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef vector&lt;<a class="el" href="struct_ogre_1_1_texture_gpu_manager_1_1_budget_entry.html">BudgetEntry</a>&gt;::type <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a243112239378b673ba9f1df5e7abdbf3">Ogre::TextureGpuManager::BudgetEntryVec</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a75e42d75a1eae1a28e52e4613832edb3" name="a75e42d75a1eae1a28e52e4613832edb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e42d75a1eae1a28e52e4613832edb3">&#9670;&nbsp;</a></span>MetadataCacheMap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef map&lt;<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>,<a class="el" href="struct_ogre_1_1_texture_gpu_manager_1_1_metadata_cache_entry.html">MetadataCacheEntry</a>&gt;::type <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a75e42d75a1eae1a28e52e4613832edb3">Ogre::TextureGpuManager::MetadataCacheMap</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad657330e7020f561860d24366460271c" name="ad657330e7020f561860d24366460271c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad657330e7020f561860d24366460271c">&#9670;&nbsp;</a></span>ResourceEntryMap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef map&lt;<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>,<a class="el" href="struct_ogre_1_1_texture_gpu_manager_1_1_resource_entry.html">ResourceEntry</a>&gt;::type <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#ad657330e7020f561860d24366460271c">Ogre::TextureGpuManager::ResourceEntryMap</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="afe11bd546cf7315f4526488e7078cc7d" name="afe11bd546cf7315f4526488e7078cc7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe11bd546cf7315f4526488e7078cc7d">&#9670;&nbsp;</a></span>Reason</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7d">Ogre::TextureGpuListener::Reason</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afe11bd546cf7315f4526488e7078cc7da2b732a317de0915527e291485ca42e82" name="afe11bd546cf7315f4526488e7078cc7da2b732a317de0915527e291485ca42e82"></a>Unknown&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afe11bd546cf7315f4526488e7078cc7da58fd07194714679ed3ba9857d7656f27" name="afe11bd546cf7315f4526488e7078cc7da58fd07194714679ed3ba9857d7656f27"></a>FromStorageToSysRam&#160;</td><td class="fielddoc"><p >OnStorage -&gt; OnSystemRam. </p>
</td></tr>
<tr><td class="fieldname"><a id="afe11bd546cf7315f4526488e7078cc7da058c0eecb9f3f188fccc4d0018bf337b" name="afe11bd546cf7315f4526488e7078cc7da058c0eecb9f3f188fccc4d0018bf337b"></a>FromSysRamToStorage&#160;</td><td class="fielddoc"><p >OnSystemRam -&gt; OnStorage. </p>
</td></tr>
<tr><td class="fieldname"><a id="afe11bd546cf7315f4526488e7078cc7da55066351a26967068b944c2170e51af1" name="afe11bd546cf7315f4526488e7078cc7da55066351a26967068b944c2170e51af1"></a>GainedResidency&#160;</td><td class="fielddoc"><p >OnStorage -&gt; Resident OnSystemRam -&gt; Resident See ReadyForRendering. </p>
</td></tr>
<tr><td class="fieldname"><a id="afe11bd546cf7315f4526488e7078cc7da61729c4ae25807d6132d5bc46580ff3d" name="afe11bd546cf7315f4526488e7078cc7da61729c4ae25807d6132d5bc46580ff3d"></a>LostResidency&#160;</td><td class="fielddoc"><p >Resident -&gt; OnStorage Resident -&gt; OnSystemRam. </p>
</td></tr>
<tr><td class="fieldname"><a id="afe11bd546cf7315f4526488e7078cc7dafbdd85981846de4423d48d1a0ff665e0" name="afe11bd546cf7315f4526488e7078cc7dafbdd85981846de4423d48d1a0ff665e0"></a>PoolTextureSlotChanged&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afe11bd546cf7315f4526488e7078cc7da218a4243be85ec9c989b777119d5ff47" name="afe11bd546cf7315f4526488e7078cc7da218a4243be85ec9c989b777119d5ff47"></a>ResidentToSysRamSync&#160;</td><td class="fielddoc"><p >Only called while <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> is still Resident, and strategy is AlwaysKeepSystemRamCopy. </p>
<p >This listener happens when something was done to the <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> that modifies its contents in the GPU, and were thus forced to sync those values back to SystemRam. This listener calls tells that sync is over. </p>
</td></tr>
<tr><td class="fieldname"><a id="afe11bd546cf7315f4526488e7078cc7da4f559ca1853a24a28b40caae1acda604" name="afe11bd546cf7315f4526488e7078cc7da4f559ca1853a24a28b40caae1acda604"></a>MetadataCacheOutOfDate&#160;</td><td class="fielddoc"><p >The Metadata cache was out of date and we had to do a ping-pong. </p>
<p >Expect this to be followed by at least LostResidency and GainedResidency calls</p>
<p >This is very important, because if you were expecting certain sequence of calls (e.g. you were expecting a LostResidency soon to arrive), expect that to be changed.</p>
<p >See <a class="el" href="class_ogre_1_1_texture_gpu_manager.html" title="This class manages all textures (i.e.">TextureGpuManager</a> for details about the metadata cache. </p>
</td></tr>
<tr><td class="fieldname"><a id="afe11bd546cf7315f4526488e7078cc7da704ea118c7e9f0b1598b528bdcbe1b26" name="afe11bd546cf7315f4526488e7078cc7da704ea118c7e9f0b1598b528bdcbe1b26"></a>ExceptionThrown&#160;</td><td class="fielddoc"><p >Called when the worker thread caught an exception. </p>
<p >This exception has already been logged, and the texture resumed loading normally with a white 2x2 RGBA8 fallback.</p>
<p >This listener will get called from the main thread.</p>
<p >The texture may still have pending residency transitions (e.g. it may still be loading the 2x2 fallback)</p>
<p >Cast <a class="el" href="class_ogre_1_1_exception.html" title="When thrown, provides information about an error that has occurred inside the engine.">Exception</a> <em>e = reinterpret_cast&lt;<a class="el" href="class_ogre_1_1_exception.html" title="When thrown, provides information about an error that has occurred inside the engine.">Exception</a></em>&gt;( extraData ); to know more info </p>
</td></tr>
<tr><td class="fieldname"><a id="afe11bd546cf7315f4526488e7078cc7dae3eb70053cbf5401f22893cdb47f81a7" name="afe11bd546cf7315f4526488e7078cc7dae3eb70053cbf5401f22893cdb47f81a7"></a>FsaaSettingAlteredByApi&#160;</td><td class="fielddoc"><p >Requested FSAA (MSAA / CSAA / EQAA / etc) is not supported by the API, and thus the setting had to be downgraded. </p>
<p >Note this may happen on device lost, and a new GPU became in use; thus it's possible for a <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> to initially support certain FSAA but later change. </p>
</td></tr>
<tr><td class="fieldname"><a id="afe11bd546cf7315f4526488e7078cc7dad4d9c6e3b7755f38d8d5f003be100257" name="afe11bd546cf7315f4526488e7078cc7dad4d9c6e3b7755f38d8d5f003be100257"></a>ReadyForRendering&#160;</td><td class="fielddoc"><p >This Reason is called when <a class="el" href="class_ogre_1_1_texture_gpu.html#abe10b3ea1bc20e616134af7b7f567446" title="Notifies it is safe to use the real data. Everything has been uploaded.">TextureGpu::notifyDataIsReady</a> is called. </p>
<p >This normally means worker thread is done loading texture from file and uploading it to GPU; and can now be used for rendering. It does NOT mean that <a class="el" href="namespace_ogre.html">Ogre</a> has finished issueing rendering commands to a <a class="el" href="class_ogre_1_1_render_texture.html" title="This class represents a RenderTarget that renders to a Texture.">RenderTexture</a> and is now ready to be presented to the monitor. </p>
</td></tr>
<tr><td class="fieldname"><a id="afe11bd546cf7315f4526488e7078cc7dabb2a61a0002ccca6afbde7588787e58e" name="afe11bd546cf7315f4526488e7078cc7dabb2a61a0002ccca6afbde7588787e58e"></a>Deleted&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3b2eb464f34ca01c6e0f60b3a7e837cf" name="a3b2eb464f34ca01c6e0f60b3a7e837cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b2eb464f34ca01c6e0f60b3a7e837cf">&#9670;&nbsp;</a></span>NULLTextureGpuManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::NULLTextureGpuManager::NULLTextureGpuManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_vao_manager.html">VaoManager</a> *&#160;</td>
          <td class="paramname"><em>vaoManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_render_system.html">RenderSystem</a> *&#160;</td>
          <td class="paramname"><em>renderSystem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04254d4d0ac0721302bff73389f19116" name="a04254d4d0ac0721302bff73389f19116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04254d4d0ac0721302bff73389f19116">&#9670;&nbsp;</a></span>~NULLTextureGpuManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::NULLTextureGpuManager::~NULLTextureGpuManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a68dec5d2c3187c3d7be56d9c5cc55fc4" name="a68dec5d2c3187c3d7be56d9c5cc55fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68dec5d2c3187c3d7be56d9c5cc55fc4">&#9670;&nbsp;</a></span>_queueDownloadToRam()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::_queueDownloadToRam </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resyncOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a89a4bb400a24d0e3ea9a9299192fa51d" name="a89a4bb400a24d0e3ea9a9299192fa51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a4bb400a24d0e3ea9a9299192fa51d">&#9670;&nbsp;</a></span>_releaseSlotFromTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::_releaseSlotFromTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Must be called from main thread. </p>

</div>
</div>
<a id="a38a3edb2437dae48c14a0d20c50877fa" name="a38a3edb2437dae48c14a0d20c50877fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38a3edb2437dae48c14a0d20c50877fa">&#9670;&nbsp;</a></span>_removeMetadataCacheEntry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::_removeMetadataCacheEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93773f33d6018c991b4fa8c475a8a36d" name="a93773f33d6018c991b4fa8c475a8a36d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93773f33d6018c991b4fa8c475a8a36d">&#9670;&nbsp;</a></span>_reserveSlotForTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::_reserveSlotForTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Must be called from main thread. </p>

</div>
</div>
<a id="a435b32507353f22b8428e6f9d849e7e1" name="a435b32507353f22b8428e6f9d849e7e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a435b32507353f22b8428e6f9d849e7e1">&#9670;&nbsp;</a></span>_scheduleTransitionTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::_scheduleTransitionTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_gpu_residency.html#a2dee9b512fd45f8d010e8e18e25ebd98">GpuResidency::GpuResidency</a>&#160;</td>
          <td class="paramname"><em>targetResidency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_image2.html">Image2</a> *&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoDeleteImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reuploadOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a46f6c11e4af75070ada1e868e7b24412" name="a46f6c11e4af75070ada1e868e7b24412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46f6c11e4af75070ada1e868e7b24412">&#9670;&nbsp;</a></span>_scheduleUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::_scheduleUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>filters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_image2.html">Image2</a> *&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoDeleteImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skipMetadataCache</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>sliceOrDepth</em> = <code>std::numeric_limits&lt;&#160;<a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae905930e6b79e3a3c3152efc20d5249c" name="ae905930e6b79e3a3c3152efc20d5249c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae905930e6b79e3a3c3152efc20d5249c">&#9670;&nbsp;</a></span>_setIgnoreScheduledTasks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::_setIgnoreScheduledTasks </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreSchedTasks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When true we will ignore all tasks in mScheduledTasks and execute transitions immediately Caller is responsible for ensuring this is safe to do. </p>
<p >The main reason for this function is that when the metadata cache is proven to be out of date and comes back to the main thread, we need to perform a Resident -&gt; OnStorage -&gt; Resident transition that bypasses pending operations, and pretend the texture has been in Resident all along. </p>

</div>
</div>
<a id="aa961b3aafc08805f7611d4edd283f804" name="aa961b3aafc08805f7611d4edd283f804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa961b3aafc08805f7611d4edd283f804">&#9670;&nbsp;</a></span>_update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpuManager::_update </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>syncWithWorkerThread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if there is no more streaming work to be done yet (if false, calls to _update could be needed once again) See waitForStreamingCompletion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">syncWithWorkerThread</td><td>When true, we will wait for the worker thread to release the main mutex instead of just continuing and trying again next time we get called. This is important for waitForStreamingCompletion &amp; _waitFor because otherwise main thread may not see worker thread has finished because it's also grabbing the main mutex; and waitForStreamingCompletion will go to sleep thinking worker thread has yet to finish, and worker thread won't wake up the main thread because it has already notified it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f6d7560d59263dc303563777b5c61e8" name="a4f6d7560d59263dc303563777b5c61e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f6d7560d59263dc303563777b5c61e8">&#9670;&nbsp;</a></span>_updateMetadataCache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::_updateMetadataCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aec3f9567c396b28a1f73a7044d9957bd" name="aec3f9567c396b28a1f73a7044d9957bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec3f9567c396b28a1f73a7044d9957bd">&#9670;&nbsp;</a></span>_updateStreaming()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::_updateStreaming </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f6ee50fe51ac71c60f66e044859bf9d" name="a4f6ee50fe51ac71c60f66e044859bf9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f6ee50fe51ac71c60f66e044859bf9d">&#9670;&nbsp;</a></span>_updateStreamingWorkerThread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long Ogre::TextureGpuManager::_updateStreamingWorkerThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_thread_handle.html">ThreadHandle</a> *&#160;</td>
          <td class="paramname"><em>threadHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c872d542fd78e2db884ff8904d4c39d" name="a2c872d542fd78e2db884ff8904d4c39d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c872d542fd78e2db884ff8904d4c39d">&#9670;&nbsp;</a></span>_waitFor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::_waitFor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>metadataOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do not use directly. See <a class="el" href="class_ogre_1_1_texture_gpu.html#a6740006ae83f39c4aeb83f300b67f6b2" title="Blocks main thread until metadata is ready.">TextureGpu::waitForMetadata</a> &amp; TextureGpu::waitForDataReady. </p>

</div>
</div>
<a id="ac55e0672860ad3ed3695374d9e12c7ba" name="ac55e0672860ad3ed3695374d9e12c7ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac55e0672860ad3ed3695374d9e12c7ba">&#9670;&nbsp;</a></span>_waitForPendingGpuToCpuSyncs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::_waitForPendingGpuToCpuSyncs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do not use directly. See TextureGpu::waitForPendingSyncs. </p>

</div>
</div>
<a id="ae4cace3a36dcc63cb0ba5662f2c29b8a" name="ae4cace3a36dcc63cb0ba5662f2c29b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4cace3a36dcc63cb0ba5662f2c29b8a">&#9670;&nbsp;</a></span>checkSupport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::TextureGpuManager::checkSupport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a>&#160;</td>
          <td class="paramname"><em>textureType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>textureFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given format with the texture flags combination is supported. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td></td></tr>
    <tr><td class="paramname">textureFlags</td><td>See <a class="el" href="namespace_ogre_1_1_texture_flags.html#a59b71e36a14465bd82595d6d467e1434">TextureFlags::TextureFlags</a> Supported flags are: NotTexture RenderToTexture Uav AllowAutomipmaps</td></tr>
  </table>
  </dd>
</dl>
<p>When NotTexture is set, we don't check whether it's possible to sample from this texture. Note that some buggy Android drivers may report that it's not possible to sample from that texture when it actually is. </p><dl class="section return"><dt>Returns</dt><dd>True if supported. False otherwise </dd></dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_metal_texture_gpu_manager.html#adac451c7c9cc5037372ec591b06383c0">Ogre::MetalTextureGpuManager</a>, and <a class="el" href="class_ogre_1_1_vulkan_texture_gpu_manager.html#abf35a03ba916bc3c4359bfd164586968">Ogre::VulkanTextureGpuManager</a>.</p>

</div>
</div>
<a id="a71e7ae62f823f48c7c4844a2d34589de" name="a71e7ae62f823f48c7c4844a2d34589de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71e7ae62f823f48c7c4844a2d34589de">&#9670;&nbsp;</a></span>createAsyncTextureTicket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_async_texture_ticket.html">AsyncTextureTicket</a> * Ogre::TextureGpuManager::createAsyncTextureTicket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>depthOrSlices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a>&#160;</td>
          <td class="paramname"><em>textureType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>pixelFormatFamily</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="class_ogre_1_1_async_texture_ticket.html" title="In Ogre 2.2 reading data from GPU back to CPU is asynchronous.">AsyncTextureTicket</a> that can be used to download data GPU -&gt; CPU from a <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a>. </p>
<p >To upload data CPU -&gt; GPU see getStagingTexture </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td></td></tr>
    <tr><td class="paramname">height</td><td></td></tr>
    <tr><td class="paramname">depthOrSlices</td><td></td></tr>
    <tr><td class="paramname">pixelFormatFamily</td><td>If the value is not a family value, it will automatically be converted to one. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ad118a876e3102b5ae6ba5cefba5bdf1d" name="ad118a876e3102b5ae6ba5cefba5bdf1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad118a876e3102b5ae6ba5cefba5bdf1d">&#9670;&nbsp;</a></span>createOrRetrieveTexture() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> * Ogre::TextureGpuManager::createOrRetrieveTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>aliasName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a>&#160;</td>
          <td class="paramname"><em>pageOutStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_common_texture_types.html#a3a978c834ce00930123468c9a64047b4">CommonTextureTypes::CommonTextureTypes</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>resourceGroup</em> = <code><a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>poolId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to call createOrRetrieveTexture with common parameters used for 2D diffuse textures loaded from file. </p>

</div>
</div>
<a id="a24f8cd49c0990fb532306a1569b58f33" name="a24f8cd49c0990fb532306a1569b58f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f8cd49c0990fb532306a1569b58f33">&#9670;&nbsp;</a></span>createOrRetrieveTexture() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> * Ogre::TextureGpuManager::createOrRetrieveTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>aliasName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a>&#160;</td>
          <td class="paramname"><em>pageOutStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>textureFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a>&#160;</td>
          <td class="paramname"><em>initialType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>resourceGroup</em> = <code><a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>filters</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>poolId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5643e2d490f3f305828e3de64e1b5934" name="a5643e2d490f3f305828e3de64e1b5934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5643e2d490f3f305828e3de64e1b5934">&#9670;&nbsp;</a></span>createOrRetrieveTexture() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> * Ogre::TextureGpuManager::createOrRetrieveTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a>&#160;</td>
          <td class="paramname"><em>pageOutStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_common_texture_types.html#a3a978c834ce00930123468c9a64047b4">CommonTextureTypes::CommonTextureTypes</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>resourceGroup</em> = <code><a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>poolId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abf67202da75b8c6f9134d7e81baa89d8" name="abf67202da75b8c6f9134d7e81baa89d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf67202da75b8c6f9134d7e81baa89d8">&#9670;&nbsp;</a></span>createOrRetrieveTexture() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> * Ogre::TextureGpuManager::createOrRetrieveTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a>&#160;</td>
          <td class="paramname"><em>pageOutStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>textureFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a>&#160;</td>
          <td class="paramname"><em>initialType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>resourceGroup</em> = <code><a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>filters</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>poolId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a017eec4324d75ffb0de6b0fc1fdd2654" name="a017eec4324d75ffb0de6b0fc1fdd2654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017eec4324d75ffb0de6b0fc1fdd2654">&#9670;&nbsp;</a></span>createTexture() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> * Ogre::TextureGpuManager::createTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>aliasName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a>&#160;</td>
          <td class="paramname"><em>pageOutStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>textureFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a>&#160;</td>
          <td class="paramname"><em>initialType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>resourceGroup</em> = <code><a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>filters</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>poolId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the resource. For example TreeWood.png </td></tr>
    <tr><td class="paramname">aliasName</td><td>Usually aliasName = name. An alias name allows you to load the same texture (e.g. TreeWood.png) with different settings. For example: Alias 0 - "Tree Wood With Mipmaps" Alias 1 - "Tree Wood Without Mipmaps" Alias 2 - "Tree Wood Without TextureFlags::AutomaticBatching" This lets you have 3 copies of the same file in memory. </td></tr>
    <tr><td class="paramname">pageOutStrategy</td><td></td></tr>
    <tr><td class="paramname">textureFlags</td><td>See <a class="el" href="namespace_ogre_1_1_texture_flags.html#a59b71e36a14465bd82595d6d467e1434">TextureFlags::TextureFlags</a> </td></tr>
    <tr><td class="paramname">initialType</td><td>Strictly not required (i.e. can be left <a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82a13888ea41a337938a549d0c5657d799d">TextureTypes::Unknown</a>) however it can be needed if set to a material before it is fully loaded; and the shader expects a particular type (e.g. it expects a cubemap). While it's not yet loaded, a dummy texture will that matches the type will be used; and it's important that the right dummy texture is selected. So if you know in advance a particular type is needed, this parameter tells <a class="el" href="namespace_ogre.html">Ogre</a> what dummy to use. </td></tr>
    <tr><td class="paramname">resourceGroup</td><td>Optional, but required if you want to load files from disk (or anything provided by the <a class="el" href="class_ogre_1_1_resource_group_manager.html" title="This singleton class manages the list of resource groups, and notifying the various resource managers...">ResourceGroupManager</a>) </td></tr>
    <tr><td class="paramname">poolId</td><td>Optional. See <a class="el" href="class_ogre_1_1_texture_gpu.html#a78bd23c2116dc08afcaa8dc1b8d2384e" title="2D Texture with automatic batching will be merged with other textures into the same pool as one big 2...">TextureGpu::setTexturePoolId</a> This parameter informs which pool ID you wish the texture to be assigned for. Note however, if you're using createOrRetrieveTexture and the texture has already been created (i.e. it's being retrieved) then the pool ID parameter will be ignored, as the texture was already created with a pool ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a8d1cdf54c1a262bc911d37235682ec1c" name="a8d1cdf54c1a262bc911d37235682ec1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1cdf54c1a262bc911d37235682ec1c">&#9670;&nbsp;</a></span>createTexture() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> * Ogre::TextureGpuManager::createTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_gpu_page_out_strategy.html#a4d2162c156be30917f38f15e2327ce65">GpuPageOutStrategy::GpuPageOutStrategy</a>&#160;</td>
          <td class="paramname"><em>pageOutStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>textureFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_texture_types.html#aa364e348564060700791c9940d5ced82">TextureTypes::TextureTypes</a>&#160;</td>
          <td class="paramname"><em>initialType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>resourceGroup</em> = <code><a class="el" href="group___general.html#gad842a4b416bd2f3245d2b44826a0aedc">BLANKSTRING</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>filters</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>poolId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93bc76576f34bab1470f094537dbce56" name="a93bc76576f34bab1470f094537dbce56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93bc76576f34bab1470f094537dbce56">&#9670;&nbsp;</a></span>createTextureGpuWindow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> * Ogre::NULLTextureGpuManager::createTextureGpuWindow </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a02832e2789d8fc68b4ce4586bad25010" name="a02832e2789d8fc68b4ce4586bad25010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02832e2789d8fc68b4ce4586bad25010">&#9670;&nbsp;</a></span>destroyAllAsyncTextureTicket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::destroyAllAsyncTextureTicket </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af906e6a5e055170b281a1986374b4754" name="af906e6a5e055170b281a1986374b4754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af906e6a5e055170b281a1986374b4754">&#9670;&nbsp;</a></span>destroyAsyncTextureTicket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::destroyAsyncTextureTicket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_async_texture_ticket.html">AsyncTextureTicket</a> *&#160;</td>
          <td class="paramname"><em>ticket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7dc898578da3113affb78ed60f209b71" name="a7dc898578da3113affb78ed60f209b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc898578da3113affb78ed60f209b71">&#9670;&nbsp;</a></span>destroyTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::destroyTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys a texture. </p>
<p >Classes who wish to hold a weak reference should listen for <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7dabb2a61a0002ccca6afbde7588787e58e">TextureGpuListener::Deleted</a> events and clear their pointers when the texture gets destroyed.</p>
<p >Classes who wish to hold a stronger reference (note: it says 'stronger', not 'strong') should return true in <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#a1427f0b635a4186cd6083a9bab879fa2" title="Return true if this TextureGpu should likely stay loaded or else graphical changes could occur.">TextureGpuListener::shouldStayLoaded</a>, but it is not guaranteed to be honoured.</p>
<p >Users should iterate through listeners and see if any listener's shouldStayLoaded returns true. If you still want to destroy the texture, the class should still be able to handle <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7dabb2a61a0002ccca6afbde7588787e58e">TextureGpuListener::Deleted</a> gracefully.</p>
<p >See MemoryGameState::unloadUnusedTextures in Tutorial_MemoryGameState.cpp</p>
<p ><a class="el" href="namespace_ogre.html">Ogre</a> doesn't call destroyTexture unless it's on shutdown or a specific Ogre-controlled texture (e.g. something related to PBS, Irradiance Fields, etc)</p>
<p >Users are the ones in control of which textures get unloaded. It is suggested users group textures by criteria so that they can be loaded and unloaded in bulk (i.e. by relation to a level, or area in an open world game, by scene, etc) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a841f10a656bbd24ed92b87f616e33f74" name="a841f10a656bbd24ed92b87f616e33f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a841f10a656bbd24ed92b87f616e33f74">&#9670;&nbsp;</a></span>dumpMemoryUsage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::dumpMemoryUsage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_log.html">Log</a> *&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">Ogre::uint32</a>&#160;</td>
          <td class="paramname"><em>mask</em> = <code><a class="el" href="namespace_ogre_1_1_residency_mask.html#a41a75eb215f69beb19a0039eb7e2b141a98b6ac43f7a59e7ed0b61a1b529f06ca">ResidencyMask::All</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b0ab5ff277943748df853653efb8913" name="a0b0ab5ff277943748df853653efb8913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0ab5ff277943748df853653efb8913">&#9670;&nbsp;</a></span>dumpStats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::dumpStats </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a400906a91ef0c5b7b61329de7872c91e" name="a400906a91ef0c5b7b61329de7872c91e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400906a91ef0c5b7b61329de7872c91e">&#9670;&nbsp;</a></span>executeTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpuManager::executeTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7d">TextureGpuListener::Reason</a>&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScheduledTasks &amp;&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a25ea160f5cd58eb1569743dee3bff9cc" name="a25ea160f5cd58eb1569743dee3bff9cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ea160f5cd58eb1569743dee3bff9cc">&#9670;&nbsp;</a></span>exportTextureMetadataCache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::exportTextureMetadataCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>outJson</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abf7dedc19c2251a15643a3e240225abd" name="abf7dedc19c2251a15643a3e240225abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf7dedc19c2251a15643a3e240225abd">&#9670;&nbsp;</a></span>findAliasNameStr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> * Ogre::TextureGpuManager::findAliasNameStr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>idName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function CAN be called from any thread. </p>

</div>
</div>
<a id="abf7a7a36c00587fb8298f4100606c627" name="abf7a7a36c00587fb8298f4100606c627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf7a7a36c00587fb8298f4100606c627">&#9670;&nbsp;</a></span>findResourceGroupStr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> * Ogre::TextureGpuManager::findResourceGroupStr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>idName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function CAN be called from any thread. </p>

</div>
</div>
<a id="a45819a2f57371a1d5ae1d026a21510ab" name="a45819a2f57371a1d5ae1d026a21510ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45819a2f57371a1d5ae1d026a21510ab">&#9670;&nbsp;</a></span>findResourceNameStr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> * Ogre::TextureGpuManager::findResourceNameStr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>idName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function CAN be called from any thread. </p>

</div>
</div>
<a id="ad7aa5c6af459eb788ed985104c21f5f7" name="ad7aa5c6af459eb788ed985104c21f5f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7aa5c6af459eb788ed985104c21f5f7">&#9670;&nbsp;</a></span>findTextureNoThrow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> * Ogre::TextureGpuManager::findTextureNoThrow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e938ff8fcf2cf1312e916b3b5078cfe" name="a5e938ff8fcf2cf1312e916b3b5078cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e938ff8fcf2cf1312e916b3b5078cfe">&#9670;&nbsp;</a></span>getBudget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a243112239378b673ba9f1df5e7abdbf3">BudgetEntryVec</a> &amp; Ogre::TextureGpuManager::getBudget </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af34d0779d8e031e998915b4528dbddb6" name="af34d0779d8e031e998915b4528dbddb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34d0779d8e031e998915b4528dbddb6">&#9670;&nbsp;</a></span>getDefaultMipmapGeneration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre_1_1_default_mipmap_gen.html#a3eb99f91a07b98f3713bf8c23069e9fb">DefaultMipmapGen::DefaultMipmapGen</a> Ogre::TextureGpuManager::getDefaultMipmapGeneration </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ace14aaadb7bf3b43b564c218186df62d" name="ace14aaadb7bf3b43b564c218186df62d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace14aaadb7bf3b43b564c218186df62d">&#9670;&nbsp;</a></span>getDefaultMipmapGenerationCubemaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre_1_1_default_mipmap_gen.html#a3eb99f91a07b98f3713bf8c23069e9fb">DefaultMipmapGen::DefaultMipmapGen</a> Ogre::TextureGpuManager::getDefaultMipmapGenerationCubemaps </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7806f6c350ad71d918f75a99fca84f0" name="ab7806f6c350ad71d918f75a99fca84f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7806f6c350ad71d918f75a99fca84f0">&#9670;&nbsp;</a></span>getEntries()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#ad657330e7020f561860d24366460271c">ResourceEntryMap</a> &amp; Ogre::TextureGpuManager::getEntries </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e9374e0a6a80f16ef5b3e95f38c2e44" name="a0e9374e0a6a80f16ef5b3e95f38c2e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9374e0a6a80f16ef5b3e95f38c2e44">&#9670;&nbsp;</a></span>getLoadRequestsCounter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a00f119d555e251922c695ec569ccfd95">uint64</a> Ogre::TextureGpuManager::getLoadRequestsCounter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calling waitForStreamingCompletion before <a class="el" href="class_ogre_1_1_root.html#aeaad25268c0ad8007ce8961a32242c77" title="Render one frame.">Root::renderOneFrame</a> should guarantee the render is perfect. </p>
<p >Except... a new texture may be loaded while inside renderOneFrame. If that happens the render may not be perfect. You can solve that by rendering the frame again if you need all frames to be 'perfect':</p>
<div class="fragment"><div class="line">textureMgr-&gt;waitForStreamingCompletion();</div>
<div class="line"><span class="keyword">const</span> oldValue = textureMgr-&gt;getLoadRequestsCounter();</div>
<div class="line">root-&gt;renderOneFrame();</div>
<div class="line"><span class="keywordflow">if</span>( oldValue != textureMgr-&gt;getLoadRequestsCounter() )</div>
<div class="line">{</div>
<div class="line">    textureMgr-&gt;waitForStreamingCompletion();</div>
<div class="line">    root-&gt;renderOneFrame();</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3886c70b1674b192547c407edeb4c67e" name="a3886c70b1674b192547c407edeb4c67e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3886c70b1674b192547c407edeb4c67e">&#9670;&nbsp;</a></span>getMemoryStats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::getMemoryStats </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>outTextureBytesCpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>outTextureBytesGpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>outUsedStagingTextureBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>outAvailableStagingTextureBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9f2c6ee08fce32295e93904e94d69fb" name="ad9f2c6ee08fce32295e93904e94d69fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f2c6ee08fce32295e93904e94d69fb">&#9670;&nbsp;</a></span>getRenderSystem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_render_system.html">RenderSystem</a> * Ogre::TextureGpuManager::getRenderSystem </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a18f2ab9f38f0dbf29a75a82030231a9f" name="a18f2ab9f38f0dbf29a75a82030231a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f2ab9f38f0dbf29a75a82030231a9f">&#9670;&nbsp;</a></span>getStagingTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_staging_texture.html">StagingTexture</a> * Ogre::TextureGpuManager::getStagingTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>slices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>pixelFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minConsumptionRatioThreshold</em> = <code>25u</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> which is required to upload data CPU -&gt; GPU into a <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a>. </p>
<p >To download data GPU -&gt; CPU see readRequest </p><dl class="section remark"><dt>Remarks</dt><dd>We try to find the smallest available texture (won't stall) that can fit the request. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minConsumptionRatioThreshold</td><td>Value in range [0; 100]. The smallest available texture we find may still be too big (e.g. you need to upload 64x64 texture RGBA8 and we return a 8192x8192x4 staging texture which is overkill). For these cases, here you can specify how much "is too big". For example by specifying a consumptionRatio of 50; it means that the data you asked for must occupy at least 50% of the space; otherwise we'll create a new <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>A value of 100 means the <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> must fit exactly (fully used). A value of 0 means any <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> will do, no matter how large.</p>
<p >StagingTextures that haven't been using in a while will be destroyed. However if for some reason we end up returning a huge texture every frame for small workloads, we'll be keeping that waste potentially forever. </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> that meets the criteria. When you're done, remove it by calling removeStagingTexture. </dd></dl>

</div>
</div>
<a id="a9b7f3c063418bd31e284fd3dbd4f585e" name="a9b7f3c063418bd31e284fd3dbd4f585e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7f3c063418bd31e284fd3dbd4f585e">&#9670;&nbsp;</a></span>getVaoManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_vao_manager.html">VaoManager</a> * Ogre::TextureGpuManager::getVaoManager </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a064b32e7db16917d223a729f3ce03a96" name="a064b32e7db16917d223a729f3ce03a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a064b32e7db16917d223a729f3ce03a96">&#9670;&nbsp;</a></span>hasPoolId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpuManager::hasPoolId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>poolId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>numMipmaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>pixelFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7152f97e84cd44d73afc86d77951120" name="ae7152f97e84cd44d73afc86d77951120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7152f97e84cd44d73afc86d77951120">&#9670;&nbsp;</a></span>hasTextureResource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpuManager::hasTextureResource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>aliasName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>resourceGroup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if a texture with the given aliasName exists, or if a <a class="el" href="class_ogre_1_1_resource_group_listener.html" title="This abstract class defines an interface which is called back during resource group loading to indica...">ResourceGroupListener</a> provides such texture, or if such texture exists (i.e. </p>
<p >as a file) in the <a class="el" href="class_ogre_1_1_resource_group_manager.html" title="This singleton class manages the list of resource groups, and notifying the various resource managers...">ResourceGroupManager</a>.</p>
<p >This can return true regardless of whether the texture has been loaded or created.</p>
<p >Not to be confused with findTextureNoThrow which only looks for already created textures. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aliasName</td><td></td></tr>
    <tr><td class="paramname">resourceGroup</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if there is such texture (loaded or not) False if there is no such texture </dd></dl>

</div>
</div>
<a id="a423e53613f85ab74171ac4bb291c2555" name="a423e53613f85ab74171ac4bb291c2555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a423e53613f85ab74171ac4bb291c2555">&#9670;&nbsp;</a></span>importTextureMetadataCache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::importTextureMetadataCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>jsonString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bCreateReservedPools</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aad2d1de6d372585cc4acfa16abae331c" name="aad2d1de6d372585cc4acfa16abae331c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad2d1de6d372585cc4acfa16abae331c">&#9670;&nbsp;</a></span>isDoneStreaming()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpuManager::isDoneStreaming </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if we're done loading all textures based on the return value of the last call to <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#aa961b3aafc08805f7611d4edd283f804" title="Returns true if there is no more streaming work to be done yet (if false, calls to _update could be n...">TextureGpuManager::_update</a> and whether new tasks have been scheduled since then. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Do NOT call this in a loop e.g.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Do not do this</span></div>
<div class="line"><span class="keywordflow">while</span>( textureGpuManager-&gt;isDoneStreaming() )</div>
<div class="line">    Sleep( 1 );</div>
</div><!-- fragment --><p >Because it will spin forever! The return value of this function changes whenever <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#aa961b3aafc08805f7611d4edd283f804" title="Returns true if there is no more streaming work to be done yet (if false, calls to _update could be n...">TextureGpuManager::_update</a> is called (directly or indirectly).</p>
<p >The main purpose for this function is to poll whether we're done streaming so that e.g. users can show/hide a loading screen or loading icon.</p>
<p >If you need to wait until all textures are done, use waitForStreamingCompletion </p>

</div>
</div>
<a id="ab2012775609f389c5f205ee089a0c8b8" name="ab2012775609f389c5f205ee089a0c8b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2012775609f389c5f205ee089a0c8b8">&#9670;&nbsp;</a></span>notifyTextureChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::TextureGpuManager::notifyTextureChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7d">TextureGpuListener::Reason</a>&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>extraData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_texture_gpu_listener.html#aad4e9062c9a92d1e2cc57d4bbe50eb95" title="Called when a TextureGpu changed in a way that affects how it is displayed:">TextureGpuListener::notifyTextureChanged</a> </dd></dl>

<p>Implements <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#aad4e9062c9a92d1e2cc57d4bbe50eb95">Ogre::TextureGpuListener</a>.</p>

</div>
</div>
<a id="a8357fe4fb4849772b94baa4bf47c7ded" name="a8357fe4fb4849772b94baa4bf47c7ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8357fe4fb4849772b94baa4bf47c7ded">&#9670;&nbsp;</a></span>operator delete() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acb46d4b0a597156d9ba5abc39d127792" name="acb46d4b0a597156d9ba5abc39d127792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb46d4b0a597156d9ba5abc39d127792">&#9670;&nbsp;</a></span>operator delete() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c727e879a260c37b00ce5505fe8e144" name="a1c727e879a260c37b00ce5505fe8e144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c727e879a260c37b00ce5505fe8e144">&#9670;&nbsp;</a></span>operator delete() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93e6a86dde5483c053ca0f2a85bbfd6c" name="a93e6a86dde5483c053ca0f2a85bbfd6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e6a86dde5483c053ca0f2a85bbfd6c">&#9670;&nbsp;</a></span>operator delete[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a595ea4c05da8aa987d3800e65d23355d" name="a595ea4c05da8aa987d3800e65d23355d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595ea4c05da8aa987d3800e65d23355d">&#9670;&nbsp;</a></span>operator delete[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1f1a983f9e2dfddee802c47bb0b1ca9" name="ad1f1a983f9e2dfddee802c47bb0b1ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f1a983f9e2dfddee802c47bb0b1ca9">&#9670;&nbsp;</a></span>operator new() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab422c67a2c8844f410fe822a357cba3b" name="ab422c67a2c8844f410fe822a357cba3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab422c67a2c8844f410fe822a357cba3b">&#9670;&nbsp;</a></span>operator new() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator new, with debug line info </p>

</div>
</div>
<a id="a63fc6bdc2eb6aeac24898a77ec5e2023" name="a63fc6bdc2eb6aeac24898a77ec5e2023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63fc6bdc2eb6aeac24898a77ec5e2023">&#9670;&nbsp;</a></span>operator new() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>placement operator new </p>

</div>
</div>
<a id="adce32528577d71b228692df906ecd17c" name="adce32528577d71b228692df906ecd17c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce32528577d71b228692df906ecd17c">&#9670;&nbsp;</a></span>operator new[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aed1464ac3de21ff20db8f9f1f8608dc7" name="aed1464ac3de21ff20db8f9f1f8608dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed1464ac3de21ff20db8f9f1f8608dc7">&#9670;&nbsp;</a></span>operator new[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>array operator new, with debug line info </p>

</div>
</div>
<a id="a614a8c355b86c01d9f7b847b670c1cd3" name="a614a8c355b86c01d9f7b847b670c1cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614a8c355b86c01d9f7b847b670c1cd3">&#9670;&nbsp;</a></span>removeStagingTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::removeStagingTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_staging_texture.html">StagingTexture</a> *&#160;</td>
          <td class="paramname"><em>stagingTexture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e96132817c27bfae1c0374e98d20dfc" name="a6e96132817c27bfae1c0374e98d20dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e96132817c27bfae1c0374e98d20dfc">&#9670;&nbsp;</a></span>reservePoolId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> * Ogre::TextureGpuManager::reservePoolId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>poolId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>numSlices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>numMipmaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga71f09fe41a1db41186262f1aa5814a18">PixelFormatGpu</a>&#160;</td>
          <td class="paramname"><em>pixelFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves and preallocates a pool with the given parameters Returns the master texture that owns the pool. </p>
<p >Destroy this pool with <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a7dc898578da3113affb78ed60f209b71" title="Destroys a texture.">TextureGpuManager::destroyTexture</a> </p>

</div>
</div>
<a id="a3796bc1de6a5a6efc208620686982b54" name="a3796bc1de6a5a6efc208620686982b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3796bc1de6a5a6efc208620686982b54">&#9670;&nbsp;</a></span>saveTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::saveTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>folderPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>savedTextures</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saveOitd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saveOriginal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hlms_texture_export_listener.html">HlmsTextureExportListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abe21fe76416e68bcfc8fe57f2655e868" name="abe21fe76416e68bcfc8fe57f2655e868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe21fe76416e68bcfc8fe57f2655e868">&#9670;&nbsp;</a></span>setDefaultMipmapGeneration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::setDefaultMipmapGeneration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_default_mipmap_gen.html#a3eb99f91a07b98f3713bf8c23069e9fb">DefaultMipmapGen::DefaultMipmapGen</a>&#160;</td>
          <td class="paramname"><em>defaultMipmapGen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_default_mipmap_gen.html#a3eb99f91a07b98f3713bf8c23069e9fb">DefaultMipmapGen::DefaultMipmapGen</a>&#160;</td>
          <td class="paramname"><em>defaultMipmapGenCubemaps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether to use HW or SW mipmap generation when specifying <a class="el" href="namespace_ogre_1_1_texture_filter.html#ad1f488159fb867da13bf2ae96f04b054a537f83d75be40b8f38b5f9dc03912afa">TextureFilter::TypeGenerateDefaultMipmaps</a> for loading files from textures. </p>
<p >This setting has no effect for filters explicitly asking for HW mipmap generation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hwMipmapGen</td><td>Whether to enable HW mipmap generation for textures. Default is true. </td></tr>
    <tr><td class="paramname">hwMipmapGenCubemaps</td><td>Whether to enable HW mipmap generation for cubemap textures. Default is false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a164a5285771064ccd10c8c2d9392d9da" name="a164a5285771064ccd10c8c2d9392d9da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164a5285771064ccd10c8c2d9392d9da">&#9670;&nbsp;</a></span>setStagingTextureMaxBudgetBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::setStagingTextureMaxBudgetBytes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stagingTextureMaxBudgetBytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>At a high level, texture loading works like this: </p>
<ol type="1">
<li>Grab a free <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> from "available" pool in main thread</li>
<li>Load image from file in secondary thread and fill the <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a></li>
<li>Copy from <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> to final <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> in main thread</li>
<li>Release the <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> so it goes back to "available" pool.</li>
<li>Repeat from step 1 for next batch of images to load. <dl class="section user"><dt></dt><dd>All is well except for one little detail in steps 1 and 4: The <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> released at step 4 can't become immediately available as the GPU could still be performing the copy from step 3, so we must wait a few frames until it's safe to map it again. </dd></dl>
<dl class="section user"><dt></dt><dd>That means at step 1, there may be StagingTextures in the "available" pool, yet however none of them are actually ready to grab; so we create a new one instead. </dd></dl>
<dl class="section user"><dt></dt><dd>In other words, if the CPU produces textures faster than the GPU can consume them, we may keep creating more and more StagingTextures until we run out of memory. </dd></dl>
<dl class="section user"><dt></dt><dd>That's where this function comes in. This function limits how much we let the "available" pool grow. If the threshold is exceeded, instead of creating a new <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> at step 1; we'll begin to stall and wait for the GPU to catch up; so we can reuse these StagingTextures again. If no <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> is capable of performing the upload (e.g. they're of incompatible format) we'll start deleting StagingTextures to make room for the one we need. The details are explained in checkStagingTextureLimits. </dd></dl>
<dl class="section user"><dt></dt><dd>This limit is tightly respected by <a class="el" href="namespace_ogre.html">Ogre</a> but not a hard one. For example if you set the limit on 256MB and we require a <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> of 326MB to load a very, very big texture, then <a class="el" href="namespace_ogre.html">Ogre</a> has no other choice but to delete all textures in mAvailableStagingTextures and create one of 326MB that can perform the operation; but <a class="el" href="namespace_ogre.html">Ogre</a> won't error out because 326 &gt; 256MB. (though in such scenario the process may run out of memory and crash) </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This limit only counts for textures that are in zero-referenced in mAvailableStagingTextures. For example if you've set the limit in 256MB and you've created 1GB worth of StagingTextures (i.e. via getStagingTexture) and never released them via removeStagingTexture; those textures don't count. We only check the limit against the released textures in mAvailableStagingTextures. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stagingTextureMaxBudgetBytes</td><td>Limit in bytes, on how much memory we let in mAvailableStagingTextures before we start stalling the GPU and/or aggressively destroying them. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ol>

</div>
</div>
<a id="af68751724984a25c311ca98459a739aa" name="af68751724984a25c311ca98459a739aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68751724984a25c311ca98459a739aa">&#9670;&nbsp;</a></span>setTextureGpuManagerListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::setTextureGpuManagerListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu_manager_listener.html">TextureGpuManagerListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a new listener. </p>
<p >The old one will be destroyed with OGRE_DELETE See <a class="el" href="class_ogre_1_1_texture_gpu_manager_listener.html">TextureGpuManagerListener</a>. Pointer cannot be null. </p>

</div>
</div>
<a id="a763c9420839cf914f7a5c1901c53539b" name="a763c9420839cf914f7a5c1901c53539b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a763c9420839cf914f7a5c1901c53539b">&#9670;&nbsp;</a></span>setTrylockMutexFailureLimit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::setTrylockMutexFailureLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>tryLockFailureLimit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The main thread tries to acquire a lock from the background thread, do something very quick, and release it. </p>
<p >If the lock failed to acquire, we try again next time _update is called. However if this happens too often in a row, we should stall and wait indefinitely for the background thread.</p>
<p >This function allows you to specify how many failures we have to let pass before we stall. </p><dl class="section remark"><dt>Remarks</dt><dd>This is a failsafe mechanism for edge case behaviors that should never happen. It is rare for the tryLock() to fail more than twice in a row.</dd></dl>
<p>However if loading a several big files (e.g. large cubemaps) or loading from a slow medium (e.g. from the internet directly) many tryLock() failures could be common.</p>
<p >If failure to acquire the lock is common and expected, small limit values could cause a lot of stutter, because e.g. a value of 3 could cause fps lag spikes every 3 frames.</p>
<p >A sensible value such as 1200 means that a stall would only happen after 20 seconds of repeated failure if running at constant 60 fps. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tryLockFailureLimit</td><td>How many failures we have to wait for a stall, expressed in calls <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#aa961b3aafc08805f7611d4edd283f804" title="Returns true if there is no more streaming work to be done yet (if false, calls to _update could be n...">TextureGpuManager::_update</a>. Usually there's one call to _update per frame, but there can be more. Use 0 to always stall Use std::numeric_limits&lt;uint32&gt;::max() for no failure limits (i.e. never stall) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb00a770d365459f490c2ecd9b96f025" name="aeb00a770d365459f490c2ecd9b96f025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb00a770d365459f490c2ecd9b96f025">&#9670;&nbsp;</a></span>setWorkerThreadMaxPerStagingTextureRequestBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::setWorkerThreadMaxPerStagingTextureRequestBytes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxPerStagingTextureRequestBytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The worker thread tracks how many data it is loading so the Main thread can request additional StagingTextures if necessary. </p>
<p >One big <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> reduces the amount of time we map memory so we can upload.</p>
<p >However one big <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> also means that if we've used 1 byte out of 200MB available, we have to wait until that byte has finished transferring (that usually means the <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> becomes available 3 frames later); which can result in three big StagingTextures (one for each frame) which can be overkill.</p>
<p >This function allows you to specify when we decide to break these requests in smaller pieces, which by default is set at 64MB </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxPerStagingTextureRequestBytes</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6de9d156bb0ef5a625f0f8a6f08a9b19" name="a6de9d156bb0ef5a625f0f8a6f08a9b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de9d156bb0ef5a625f0f8a6f08a9b19">&#9670;&nbsp;</a></span>setWorkerThreadMaxPreloadBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::setWorkerThreadMaxPreloadBytes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxPreloadBytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The worker thread first loads the texture from disk to RAM (aka "preload", and then copies from RAM to <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a>. </p>
<p >Later the main thread will copy from <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> to actual texture. </p><dl class="section user"><dt></dt><dd>This value controls how many bytes are preloaded (i.e. from disk to RAM) by the worker thread until the next _update call from the main thread is issued. </dd></dl>
<dl class="section user"><dt></dt><dd>Higher values allows worker thread to keep loading textures while your main thread loads the rest of the scene. Lower values prevent Out of Memory conditions. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Due to how the code works, this value will also affect how much <a class="el" href="class_ogre_1_1_staging_texture.html" title="A StagingTexture is an intermediate texture that can be read and be written from both CPU &amp; GPU.">StagingTexture</a> we ask to the main thread (because preloading becomes a bottleneck). </dd></dl>
<dl class="section user"><dt></dt><dd>Testing shows that very high values (i.e. &gt;256MB) have the potential of uncovering driver bugs (even in 64-bit builds) and thus are not recommended. </dd></dl>
<dl class="section user"><dt></dt><dd>The value is an approximation and not a hard limit. e.g. if loading a 128MB cubemap and the limit is 1 byte; then we'll preload 128MBs. But we won't be loading anything else. Also due to how the code works, there is some broad granularity issues that can cause us to consume a bit more. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxPreloadBytes</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9065d7ce750a69d07f0d315d623b2cc" name="ab9065d7ce750a69d07f0d315d623b2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9065d7ce750a69d07f0d315d623b2cc">&#9670;&nbsp;</a></span>setWorkerThreadMinimumBudget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::setWorkerThreadMinimumBudget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_texture_gpu_manager.html#a243112239378b673ba9f1df5e7abdbf3">BudgetEntryVec</a> &amp;&#160;</td>
          <td class="paramname"><em>budget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxSplitResolution</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Background streaming works by having a bunch of preallocated StagingTextures so we're ready to start uploading as soon as we see a request to load a texture from file. </p>
<dl class="section user"><dt></dt><dd>If there is no minimum budget or it is too small for the texture you're trying to load, background threads can't start as soon as possible and has to wait until the next call to _update (or to waitForStreamingCompletion). This controls how much memory we reserve. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Be careful on reserving too much memory, or else Out of Memory situations could arise. The amount of memory you can reserved is limited by the GTT (Graphics Translation Table) and the limit may be much lower than the total System RAM. For example my 16GB RAM system with a 2GB GPU, the GTT limit on Linux is of 3GB (use radeontop to find this information). See <a href="https://en.wikipedia.org/wiki/Graphics_address_remapping_table">https://en.wikipedia.org/wiki/Graphics_address_remapping_table</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">budget</td><td>Array of parameters for the staging textures we'll reserve. The budget can be empty. </td></tr>
    <tr><td class="paramname">maxSplitResolution</td><td>Textures bigger than this resolution in any axis will be taken as "exceptions" or "spikes" that won't last long. e.g. if maxSplitResolution = 2048 then a 2048x16, 67x2048, 2048x2048, and a 4096x4096 texture will all be considered abnormal.</td></tr>
  </table>
  </dd>
</dl>
<p>This can significantly affect how much memory we consume while streaming. A value of 0 means to keep current value.</p>
<p >If an entry in the budget contains minNumSlices &gt; 1 and minResolution &gt;= maxSplitResolution then a lot of memory waste could end up being caused; thus we will warn to the Ogre.log if you set such setting.</p>
<p >The default value in 32-bit systems and mobile is 2048 The default value in 64-bit Desktop systems is 4096</p>
<p >This setting is closely related to setWorkerThreadMaxPerStagingTextureRequestBytes, because a texture whose resolution is &gt;= maxSplitResolution will force us to use multiple StagingTextures, thus relieving the pressure on memory and memory fragmentation. </p>

</div>
</div>
<a id="a1427f0b635a4186cd6083a9bab879fa2" name="a1427f0b635a4186cd6083a9bab879fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1427f0b635a4186cd6083a9bab879fa2">&#9670;&nbsp;</a></span>shouldStayLoaded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::TextureGpuListener::shouldStayLoaded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> should likely stay loaded or else graphical changes could occur. </p>
<p >Return false if it is certainly safe to unload. </p>

<p>Reimplemented in <a class="el" href="group___resources.html#gafcb88d3a6bd52d7f4959f4a20c90e7b2">Ogre::OGRE_HLMS_TEXTURE_BASE_CLASS</a>, and <a class="el" href="class_ogre_1_1_vct_lighting.html#a47f95e656a09ffdb90066b38478ec03c">Ogre::VctLighting</a>.</p>

</div>
</div>
<a id="a1188e251546ab3391ef646d60f2317d8" name="a1188e251546ab3391ef646d60f2317d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1188e251546ab3391ef646d60f2317d8">&#9670;&nbsp;</a></span>shutdown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::shutdown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0beb6964d2f52e28e852666257a30514" name="a0beb6964d2f52e28e852666257a30514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0beb6964d2f52e28e852666257a30514">&#9670;&nbsp;</a></span>taskLoadToSysRamOrResident()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::taskLoadToSysRamOrResident </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScheduledTasks &amp;&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements TaskTypeResidencyTransition when doing any of the following transitions: OnStorage -&gt; Resident OnStorage -&gt; OnSystemRam OnSystemRam -&gt; Resident. </p>

</div>
</div>
<a id="a379578bf252f5fcf0c5168f0a88c2130" name="a379578bf252f5fcf0c5168f0a88c2130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a379578bf252f5fcf0c5168f0a88c2130">&#9670;&nbsp;</a></span>taskToUnloadOrDestroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::taskToUnloadOrDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScheduledTasks &amp;&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements TaskTypeResidencyTransition when doing any of the following transitions: Resident -&gt; OnStorage Resident -&gt; OnSystemRam OnSystemRam -&gt; OnStorage. </p>
<p >Also implements TaskTypeDestroyTexture </p>

</div>
</div>
<a id="abcf4123dc9b7b5242acac4bc1d9eef1a" name="abcf4123dc9b7b5242acac4bc1d9eef1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcf4123dc9b7b5242acac4bc1d9eef1a">&#9670;&nbsp;</a></span>waitForStreamingCompletion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::TextureGpuManager::waitForStreamingCompletion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocks main thread until all pending textures are fully loaded. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a1146a2b41f0f3f5d3b0b1bab1e74248d" name="a1146a2b41f0f3f5d3b0b1bab1e74248d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1146a2b41f0f3f5d3b0b1bab1e74248d">&#9670;&nbsp;</a></span>mIgnoreSRgbPreference</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::TextureGpuManager::mIgnoreSRgbPreference</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>While true, calls to createTexture &amp; createOrRetrieveTexture will ignore and unset the <a class="el" href="namespace_ogre_1_1_texture_flags.html#a59b71e36a14465bd82595d6d467e1434aac3ff5c1bb3a3ef222a7eef0d83836ba" title="Prefer loading FROM FILES as sRGB when possible.">TextureFlags::PrefersLoadingFromFileAsSRGB</a> flag. </p>
<p >This is useful if user is not doing PBR, or working in its own colour space manually handled.</p>
<p >Default value is false</p>
<dl class="section remark"><dt>Remarks</dt><dd>PUBLIC VARIABLE. This variable can be altered directly. Changes are reflected immediately.</dd></dl>
<p>Changes will be reflected on new textures. Existing textures no longer possess the information to know whether they were created w/ PrefersLoadingFromFileAsSRGB</p>
<p >This value is not read nor write from the worker thread, thus it is thread-safe.</p>
<p >Textures may still be loaded as SRGB if they explicitly request SRGB e.g. <code>texture-&gt;setPixelFormat( PFG_RGBA8_UNORM_SRGB )</code> was called or the texture is loaded from an OITD or DDS format specifically asking for PFG_RGBA8_UNORM_SRGB.</p>
<p >What this flag controls is that if we're loading a regular texture asking for PFG_RGBA8_UNORM like PNG (and other linear formats) then should we honour PrefersLoadingFromFileAsSRGB flag or not. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_n_u_l_l_texture_gpu_manager_8h.html">OgreNULLTextureGpuManager.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_n_u_l_l_texture_gpu_manager.html">NULLTextureGpuManager</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
