<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Ogre::v1::MetalHardwareIndexBuffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE<span id="projectnumber">&#160;2.3</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_ogre_1_1v1_1_1_metal_hardware_index_buffer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_ogre_1_1v1_1_1_metal_hardware_index_buffer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ogre::v1::MetalHardwareIndexBuffer Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Specialisation of <a class="el" href="class_ogre_1_1v1_1_1_hardware_index_buffer.html" title="Specialisation of HardwareBuffer for vertex index buffers, still abstract.">HardwareIndexBuffer</a> for Metal.  
 <a href="class_ogre_1_1v1_1_1_metal_hardware_index_buffer.html#details">More...</a></p>

<p><code>#include &lt;OgreMetalHardwareIndexBuffer.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::v1::MetalHardwareIndexBuffer:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1v1_1_1_metal_hardware_index_buffer__inherit__graph.svg" width="207" height="272"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a06f21d817782a7f95017e59581b9ddb5" id="r_a06f21d817782a7f95017e59581b9ddb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_property.html">typedef</a> <a class="el" href="group___general.html#ga496e620c45a7855770e490d92611ad19">Ogre::IndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_index_buffer.html#a06f21d817782a7f95017e59581b9ddb5">IndexType</a></td></tr>
<tr class="separator:a06f21d817782a7f95017e59581b9ddb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c56e93ce6f29bf39fb48c3d5dc64cf" id="r_ac0c56e93ce6f29bf39fb48c3d5dc64cf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#ac0c56e93ce6f29bf39fb48c3d5dc64cf">LockOptions</a> { <br />
&#160;&#160;<a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#ac0c56e93ce6f29bf39fb48c3d5dc64cfaf32b55fa8a975d085b07236f89900f26">HBL_NORMAL</a>
, <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#ac0c56e93ce6f29bf39fb48c3d5dc64cfa364f94b757045261468e68fe09c36cca">HBL_DISCARD</a>
, <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#ac0c56e93ce6f29bf39fb48c3d5dc64cfa688a3812b47db689eebdbfefca66df87">HBL_READ_ONLY</a>
, <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#ac0c56e93ce6f29bf39fb48c3d5dc64cfae160717b1f864d2d91aa2ba24ac38771">HBL_NO_OVERWRITE</a>
, <br />
&#160;&#160;<a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#ac0c56e93ce6f29bf39fb48c3d5dc64cfaacdcbae3ae1ce82b2f4411df53a545cb">HBL_WRITE_ONLY</a>
<br />
 }</td></tr>
<tr class="memdesc:ac0c56e93ce6f29bf39fb48c3d5dc64cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locking options.  <a href="class_ogre_1_1v1_1_1_hardware_buffer.html#ac0c56e93ce6f29bf39fb48c3d5dc64cf">More...</a><br /></td></tr>
<tr class="separator:ac0c56e93ce6f29bf39fb48c3d5dc64cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87632db14ce9c10e113f1966c6a97c6d" id="r_a87632db14ce9c10e113f1966c6a97c6d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a87632db14ce9c10e113f1966c6a97c6d">Usage</a> { <br />
&#160;&#160;<a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a87632db14ce9c10e113f1966c6a97c6da0c8055304cee698c19e3080e34202430">HBU_STATIC</a> = 1
, <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a87632db14ce9c10e113f1966c6a97c6da1de64eadc98dfb60e9dcdf7fe6287c09">HBU_DYNAMIC</a> = 2
, <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a87632db14ce9c10e113f1966c6a97c6da905091fc68f6e649aaa4e4aa0d5002ad">HBU_WRITE_ONLY</a> = 4
, <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a87632db14ce9c10e113f1966c6a97c6dac13bff725acd9c2ba76d95b6c700d659">HBU_DISCARDABLE</a> = 8
, <br />
&#160;&#160;<a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a87632db14ce9c10e113f1966c6a97c6dab5fe6ef729ea615265721a10ff7d9e57">HBU_STATIC_WRITE_ONLY</a> = 5
, <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a87632db14ce9c10e113f1966c6a97c6da951a42185ad1d0df6294822dedcafce7">HBU_DYNAMIC_WRITE_ONLY</a> = 6
, <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a87632db14ce9c10e113f1966c6a97c6da3756a6536dc4f8a6c3434b704537c0eb">HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE</a> = 14
<br />
 }</td></tr>
<tr class="memdesc:a87632db14ce9c10e113f1966c6a97c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enums describing buffer usage; not mutually exclusive.  <a href="class_ogre_1_1v1_1_1_hardware_buffer.html#a87632db14ce9c10e113f1966c6a97c6d">More...</a><br /></td></tr>
<tr class="separator:a87632db14ce9c10e113f1966c6a97c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaa1cb211b252381c3cc2ae3e5fa7b51e" id="r_aaa1cb211b252381c3cc2ae3e5fa7b51e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_metal_hardware_index_buffer.html#aaa1cb211b252381c3cc2ae3e5fa7b51e">MetalHardwareIndexBuffer</a> (<a class="el" href="class_ogre_1_1v1_1_1_metal_hardware_buffer_manager_base.html">MetalHardwareBufferManagerBase</a> *<a class="el" href="class_ogre_1_1_property.html">mgr</a>, <a class="el" href="group___general.html#ga496e620c45a7855770e490d92611ad19">IndexType</a> <a class="el" href="class_ogre_1_1_property.html">idxType</a>, <a class="el" href="class_ogre_1_1_property.html">size_t</a> <a class="el" href="class_ogre_1_1_property.html">numIndexes</a>, <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a87632db14ce9c10e113f1966c6a97c6d">HardwareBuffer::Usage</a> usage, <a class="el" href="class_ogre_1_1_property.html">bool</a> <a class="el" href="class_ogre_1_1_property.html">useShadowBuffer</a>)</td></tr>
<tr class="separator:aaa1cb211b252381c3cc2ae3e5fa7b51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb54c4cb1733973849f4831092143abb" id="r_acb54c4cb1733973849f4831092143abb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_property.html">virtual</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_metal_hardware_index_buffer.html#acb54c4cb1733973849f4831092143abb">~MetalHardwareIndexBuffer</a> ()</td></tr>
<tr class="separator:acb54c4cb1733973849f4831092143abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22a293cd1ffef8144c1206c67a1b8c7" id="r_ad22a293cd1ffef8144c1206c67a1b8c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_property.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_metal_hardware_index_buffer.html#ad22a293cd1ffef8144c1206c67a1b8c7">_notifyDeviceStalled</a> (<a class="el" href="class_ogre_1_1_property.html">void</a>)</td></tr>
<tr class="separator:ad22a293cd1ffef8144c1206c67a1b8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56c77c33e3c0f9634dcfc9b900be955" id="r_ae56c77c33e3c0f9634dcfc9b900be955"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_property.html">virtual</a> <a class="el" href="class_ogre_1_1_property.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_metal_hardware_index_buffer.html#ae56c77c33e3c0f9634dcfc9b900be955">_updateFromShadow</a> (<a class="el" href="class_ogre_1_1_property.html">void</a>)</td></tr>
<tr class="memdesc:ae56c77c33e3c0f9634dcfc9b900be955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the real buffer from the shadow buffer, if required.  <br /></td></tr>
<tr class="separator:ae56c77c33e3c0f9634dcfc9b900be955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5caebd4b5db7696029eb412351d7767f" id="r_a5caebd4b5db7696029eb412351d7767f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_property.html">virtual</a> <a class="el" href="class_ogre_1_1_property.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a5caebd4b5db7696029eb412351d7767f">copyData</a> (<a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html">HardwareBuffer</a> &amp;<a class="el" href="class_ogre_1_1_property.html">srcBuffer</a>)</td></tr>
<tr class="memdesc:a5caebd4b5db7696029eb412351d7767f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all data from another buffer into this one.  <br /></td></tr>
<tr class="separator:a5caebd4b5db7696029eb412351d7767f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefcabd6287c8c73859046db3b6899606" id="r_aefcabd6287c8c73859046db3b6899606"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_property.html">virtual</a> <a class="el" href="class_ogre_1_1_property.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_metal_hardware_index_buffer.html#aefcabd6287c8c73859046db3b6899606">copyData</a> (<a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html">HardwareBuffer</a> &amp;<a class="el" href="class_ogre_1_1_property.html">srcBuffer</a>, <a class="el" href="class_ogre_1_1_property.html">size_t</a> srcOffset, <a class="el" href="class_ogre_1_1_property.html">size_t</a> dstOffset, <a class="el" href="class_ogre_1_1_property.html">size_t</a> length, <a class="el" href="class_ogre_1_1_property.html">bool</a> <a class="el" href="class_ogre_1_1_property.html">discardWholeBuffer</a>=<a class="el" href="class_ogre_1_1_property.html">false</a>)</td></tr>
<tr class="memdesc:aefcabd6287c8c73859046db3b6899606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from another buffer into this one.  <br /></td></tr>
<tr class="separator:aefcabd6287c8c73859046db3b6899606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac7207feb85f1edb25bf43a69e36415" id="r_a2ac7207feb85f1edb25bf43a69e36415"><td class="memItemLeft" align="right" valign="top">id&lt; <a class="el" href="class_ogre_1_1_property.html">MTLBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_metal_hardware_index_buffer.html#a2ac7207feb85f1edb25bf43a69e36415">getBufferName</a> (<a class="el" href="class_ogre_1_1_property.html">size_t</a> &amp;<a class="el" href="class_ogre_1_1_property.html">outOffset</a>)</td></tr>
<tr class="memdesc:a2ac7207feb85f1edb25bf43a69e36415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the actual API buffer, but first sets mLastFrameUsed as we assume you're calling this function to use the buffer in the GPU.    <br /></td></tr>
<tr class="separator:a2ac7207feb85f1edb25bf43a69e36415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e333e9e57208cd9770b814544725ac" id="r_a27e333e9e57208cd9770b814544725ac"><td class="memItemLeft" align="right" valign="top">id&lt; <a class="el" href="class_ogre_1_1_property.html">MTLBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_metal_hardware_index_buffer.html#a27e333e9e57208cd9770b814544725ac">getBufferNameForGpuWrite</a> (<a class="el" href="class_ogre_1_1_property.html">void</a>)</td></tr>
<tr class="separator:a27e333e9e57208cd9770b814544725ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36fe33b74e8d2e3ce779026d264eb4b7" id="r_a36fe33b74e8d2e3ce779026d264eb4b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_property.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_index_buffer.html#a36fe33b74e8d2e3ce779026d264eb4b7">getIndexSize</a> (<a class="el" href="class_ogre_1_1_property.html">void</a>) <a class="el" href="class_ogre_1_1_property.html">const</a></td></tr>
<tr class="memdesc:a36fe33b74e8d2e3ce779026d264eb4b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size in bytes of each index.  <br /></td></tr>
<tr class="separator:a36fe33b74e8d2e3ce779026d264eb4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b05fc8856aa8aa9da03d026a3cc0a8" id="r_a76b05fc8856aa8aa9da03d026a3cc0a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager_base.html">HardwareBufferManagerBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_index_buffer.html#a76b05fc8856aa8aa9da03d026a3cc0a8">getManager</a> () <a class="el" href="class_ogre_1_1_property.html">const</a></td></tr>
<tr class="memdesc:a76b05fc8856aa8aa9da03d026a3cc0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the manager of this buffer, if any.  <br /></td></tr>
<tr class="separator:a76b05fc8856aa8aa9da03d026a3cc0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428851931d37291897ec94487e621782" id="r_a428851931d37291897ec94487e621782"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_property.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_index_buffer.html#a428851931d37291897ec94487e621782">getNumIndexes</a> (<a class="el" href="class_ogre_1_1_property.html">void</a>) <a class="el" href="class_ogre_1_1_property.html">const</a></td></tr>
<tr class="memdesc:a428851931d37291897ec94487e621782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of indexes in this buffer.  <br /></td></tr>
<tr class="separator:a428851931d37291897ec94487e621782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43cf91661a3183b399135646661d4e0f" id="r_a43cf91661a3183b399135646661d4e0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_property.html">virtual</a> <a class="el" href="class_ogre_1_1_property.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_metal_hardware_index_buffer.html#a43cf91661a3183b399135646661d4e0f">getRenderSystemData</a> (<a class="el" href="class_ogre_1_1_property.html">void</a>)</td></tr>
<tr class="memdesc:a43cf91661a3183b399135646661d4e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An internal function that should be used only by a render system for internal use.  <br /></td></tr>
<tr class="separator:a43cf91661a3183b399135646661d4e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6776e40af767f8db7d428f35d9b3055c" id="r_a6776e40af767f8db7d428f35d9b3055c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_property.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a6776e40af767f8db7d428f35d9b3055c">getSizeInBytes</a> (<a class="el" href="class_ogre_1_1_property.html">void</a>) <a class="el" href="class_ogre_1_1_property.html">const</a></td></tr>
<tr class="memdesc:a6776e40af767f8db7d428f35d9b3055c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of this buffer in bytes.  <br /></td></tr>
<tr class="separator:a6776e40af767f8db7d428f35d9b3055c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8877417cc9443facdcc362be2fe72e2" id="r_aa8877417cc9443facdcc362be2fe72e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___general.html#ga496e620c45a7855770e490d92611ad19">IndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_index_buffer.html#aa8877417cc9443facdcc362be2fe72e2">getType</a> (<a class="el" href="class_ogre_1_1_property.html">void</a>) <a class="el" href="class_ogre_1_1_property.html">const</a></td></tr>
<tr class="memdesc:aa8877417cc9443facdcc362be2fe72e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of indexes used in this buffer.  <br /></td></tr>
<tr class="separator:aa8877417cc9443facdcc362be2fe72e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d667c1abc2577fa7754ea44dd684b3" id="r_a82d667c1abc2577fa7754ea44dd684b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a87632db14ce9c10e113f1966c6a97c6d">Usage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a82d667c1abc2577fa7754ea44dd684b3">getUsage</a> (<a class="el" href="class_ogre_1_1_property.html">void</a>) <a class="el" href="class_ogre_1_1_property.html">const</a></td></tr>
<tr class="memdesc:a82d667c1abc2577fa7754ea44dd684b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Usage flags with which this buffer was created.  <br /></td></tr>
<tr class="separator:a82d667c1abc2577fa7754ea44dd684b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e1ae8b6ec0a783e89e7c83e6aee49d" id="r_ae1e1ae8b6ec0a783e89e7c83e6aee49d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_property.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#ae1e1ae8b6ec0a783e89e7c83e6aee49d">hasShadowBuffer</a> (<a class="el" href="class_ogre_1_1_property.html">void</a>) <a class="el" href="class_ogre_1_1_property.html">const</a></td></tr>
<tr class="memdesc:ae1e1ae8b6ec0a783e89e7c83e6aee49d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this buffer has a system memory shadow for quicker reading.  <br /></td></tr>
<tr class="separator:ae1e1ae8b6ec0a783e89e7c83e6aee49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9cbd2da85d59fe5ef6d5fa348052cd8" id="r_ac9cbd2da85d59fe5ef6d5fa348052cd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_property.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#ac9cbd2da85d59fe5ef6d5fa348052cd8">isLocked</a> (<a class="el" href="class_ogre_1_1_property.html">void</a>) <a class="el" href="class_ogre_1_1_property.html">const</a></td></tr>
<tr class="memdesc:ac9cbd2da85d59fe5ef6d5fa348052cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this buffer is currently locked.  <br /></td></tr>
<tr class="separator:ac9cbd2da85d59fe5ef6d5fa348052cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d97282de4e5937ff00cf2ff14860a8" id="r_ac6d97282de4e5937ff00cf2ff14860a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_property.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#ac6d97282de4e5937ff00cf2ff14860a8">isSystemMemory</a> (<a class="el" href="class_ogre_1_1_property.html">void</a>) <a class="el" href="class_ogre_1_1_property.html">const</a></td></tr>
<tr class="memdesc:ac6d97282de4e5937ff00cf2ff14860a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this buffer is held in system memory.  <br /></td></tr>
<tr class="separator:ac6d97282de4e5937ff00cf2ff14860a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15616b1645a8d88b0824b77a3cca3a78" id="r_a15616b1645a8d88b0824b77a3cca3a78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_property.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a15616b1645a8d88b0824b77a3cca3a78">lock</a> (<a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#ac0c56e93ce6f29bf39fb48c3d5dc64cf">LockOptions</a> <a class="el" href="class_ogre_1_1_property.html">options</a>)</td></tr>
<tr class="memdesc:a15616b1645a8d88b0824b77a3cca3a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the entire buffer for (potentially) reading / writing.  <br /></td></tr>
<tr class="separator:a15616b1645a8d88b0824b77a3cca3a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31666db1708eb234e02e0c2cf4c7973b" id="r_a31666db1708eb234e02e0c2cf4c7973b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_property.html">virtual</a> <a class="el" href="class_ogre_1_1_property.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a31666db1708eb234e02e0c2cf4c7973b">lock</a> (<a class="el" href="class_ogre_1_1_property.html">size_t</a> offset, <a class="el" href="class_ogre_1_1_property.html">size_t</a> length, <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#ac0c56e93ce6f29bf39fb48c3d5dc64cf">LockOptions</a> <a class="el" href="class_ogre_1_1_property.html">options</a>)</td></tr>
<tr class="memdesc:a31666db1708eb234e02e0c2cf4c7973b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the buffer for (potentially) reading / writing.  <br /></td></tr>
<tr class="separator:a31666db1708eb234e02e0c2cf4c7973b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8357fe4fb4849772b94baa4bf47c7ded" id="r_a8357fe4fb4849772b94baa4bf47c7ded"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_property.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a8357fe4fb4849772b94baa4bf47c7ded">operator delete</a> (<a class="el" href="class_ogre_1_1_property.html">void</a> *ptr)</td></tr>
<tr class="separator:a8357fe4fb4849772b94baa4bf47c7ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb46d4b0a597156d9ba5abc39d127792" id="r_acb46d4b0a597156d9ba5abc39d127792"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_property.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#acb46d4b0a597156d9ba5abc39d127792">operator delete</a> (<a class="el" href="class_ogre_1_1_property.html">void</a> *ptr, <a class="el" href="class_ogre_1_1_property.html">const</a> <a class="el" href="class_ogre_1_1_property.html">char</a> *, <a class="el" href="class_ogre_1_1_property.html">int</a>, <a class="el" href="class_ogre_1_1_property.html">const</a> <a class="el" href="class_ogre_1_1_property.html">char</a> *)</td></tr>
<tr class="separator:acb46d4b0a597156d9ba5abc39d127792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c727e879a260c37b00ce5505fe8e144" id="r_a1c727e879a260c37b00ce5505fe8e144"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_property.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a1c727e879a260c37b00ce5505fe8e144">operator delete</a> (<a class="el" href="class_ogre_1_1_property.html">void</a> *ptr, <a class="el" href="class_ogre_1_1_property.html">void</a> *)</td></tr>
<tr class="separator:a1c727e879a260c37b00ce5505fe8e144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e6a86dde5483c053ca0f2a85bbfd6c" id="r_a93e6a86dde5483c053ca0f2a85bbfd6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_property.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a93e6a86dde5483c053ca0f2a85bbfd6c">operator delete[]</a> (<a class="el" href="class_ogre_1_1_property.html">void</a> *ptr)</td></tr>
<tr class="separator:a93e6a86dde5483c053ca0f2a85bbfd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595ea4c05da8aa987d3800e65d23355d" id="r_a595ea4c05da8aa987d3800e65d23355d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_property.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a595ea4c05da8aa987d3800e65d23355d">operator delete[]</a> (<a class="el" href="class_ogre_1_1_property.html">void</a> *ptr, <a class="el" href="class_ogre_1_1_property.html">const</a> <a class="el" href="class_ogre_1_1_property.html">char</a> *, <a class="el" href="class_ogre_1_1_property.html">int</a>, <a class="el" href="class_ogre_1_1_property.html">const</a> <a class="el" href="class_ogre_1_1_property.html">char</a> *)</td></tr>
<tr class="separator:a595ea4c05da8aa987d3800e65d23355d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f1a983f9e2dfddee802c47bb0b1ca9" id="r_ad1f1a983f9e2dfddee802c47bb0b1ca9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_property.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#ad1f1a983f9e2dfddee802c47bb0b1ca9">operator new</a> (<a class="el" href="class_ogre_1_1_property.html">size_t</a> <a class="el" href="class_ogre_1_1_property.html">sz</a>)</td></tr>
<tr class="separator:ad1f1a983f9e2dfddee802c47bb0b1ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab422c67a2c8844f410fe822a357cba3b" id="r_ab422c67a2c8844f410fe822a357cba3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_property.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#ab422c67a2c8844f410fe822a357cba3b">operator new</a> (<a class="el" href="class_ogre_1_1_property.html">size_t</a> <a class="el" href="class_ogre_1_1_property.html">sz</a>, <a class="el" href="class_ogre_1_1_property.html">const</a> <a class="el" href="class_ogre_1_1_property.html">char</a> *file, <a class="el" href="class_ogre_1_1_property.html">int</a> line, <a class="el" href="class_ogre_1_1_property.html">const</a> <a class="el" href="class_ogre_1_1_property.html">char</a> *<a class="el" href="class_ogre_1_1_property.html">func</a>)</td></tr>
<tr class="memdesc:ab422c67a2c8844f410fe822a357cba3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator new, with debug line info  <br /></td></tr>
<tr class="separator:ab422c67a2c8844f410fe822a357cba3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63fc6bdc2eb6aeac24898a77ec5e2023" id="r_a63fc6bdc2eb6aeac24898a77ec5e2023"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_property.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a63fc6bdc2eb6aeac24898a77ec5e2023">operator new</a> (<a class="el" href="class_ogre_1_1_property.html">size_t</a> <a class="el" href="class_ogre_1_1_property.html">sz</a>, <a class="el" href="class_ogre_1_1_property.html">void</a> *ptr)</td></tr>
<tr class="memdesc:a63fc6bdc2eb6aeac24898a77ec5e2023"><td class="mdescLeft">&#160;</td><td class="mdescRight">placement operator new  <br /></td></tr>
<tr class="separator:a63fc6bdc2eb6aeac24898a77ec5e2023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce32528577d71b228692df906ecd17c" id="r_adce32528577d71b228692df906ecd17c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_property.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#adce32528577d71b228692df906ecd17c">operator new[]</a> (<a class="el" href="class_ogre_1_1_property.html">size_t</a> <a class="el" href="class_ogre_1_1_property.html">sz</a>)</td></tr>
<tr class="separator:adce32528577d71b228692df906ecd17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1464ac3de21ff20db8f9f1f8608dc7" id="r_aed1464ac3de21ff20db8f9f1f8608dc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_property.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#aed1464ac3de21ff20db8f9f1f8608dc7">operator new[]</a> (<a class="el" href="class_ogre_1_1_property.html">size_t</a> <a class="el" href="class_ogre_1_1_property.html">sz</a>, <a class="el" href="class_ogre_1_1_property.html">const</a> <a class="el" href="class_ogre_1_1_property.html">char</a> *file, <a class="el" href="class_ogre_1_1_property.html">int</a> line, <a class="el" href="class_ogre_1_1_property.html">const</a> <a class="el" href="class_ogre_1_1_property.html">char</a> *<a class="el" href="class_ogre_1_1_property.html">func</a>)</td></tr>
<tr class="memdesc:aed1464ac3de21ff20db8f9f1f8608dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">array operator new, with debug line info  <br /></td></tr>
<tr class="separator:aed1464ac3de21ff20db8f9f1f8608dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14766de5631308c2068c0e2510e7fe6f" id="r_a14766de5631308c2068c0e2510e7fe6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_property.html">virtual</a> <a class="el" href="class_ogre_1_1_property.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_metal_hardware_index_buffer.html#a14766de5631308c2068c0e2510e7fe6f">readData</a> (<a class="el" href="class_ogre_1_1_property.html">size_t</a> offset, <a class="el" href="class_ogre_1_1_property.html">size_t</a> length, <a class="el" href="class_ogre_1_1_property.html">void</a> *<a class="el" href="class_ogre_1_1_property.html">pDest</a>)</td></tr>
<tr class="memdesc:a14766de5631308c2068c0e2510e7fe6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from the buffer and places it in the memory pointed to by pDest.  <br /></td></tr>
<tr class="separator:a14766de5631308c2068c0e2510e7fe6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4674ce75bfc84fa7e6ac03a059f0dbb5" id="r_a4674ce75bfc84fa7e6ac03a059f0dbb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_property.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a4674ce75bfc84fa7e6ac03a059f0dbb5">suppressHardwareUpdate</a> (<a class="el" href="class_ogre_1_1_property.html">bool</a> <a class="el" href="class_ogre_1_1_property.html">suppress</a>)</td></tr>
<tr class="memdesc:a4674ce75bfc84fa7e6ac03a059f0dbb5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> true to suppress hardware upload of shadow buffer changes.  <br /></td></tr>
<tr class="separator:a4674ce75bfc84fa7e6ac03a059f0dbb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20e63654b67a94b3836c52f9c81da99" id="r_ac20e63654b67a94b3836c52f9c81da99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_property.html">virtual</a> <a class="el" href="class_ogre_1_1_property.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#ac20e63654b67a94b3836c52f9c81da99">unlock</a> (<a class="el" href="class_ogre_1_1_property.html">void</a>)</td></tr>
<tr class="memdesc:ac20e63654b67a94b3836c52f9c81da99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the lock on this buffer.  <br /></td></tr>
<tr class="separator:ac20e63654b67a94b3836c52f9c81da99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f914cf11e7381eb9dadd2f6ed40e7ff" id="r_a2f914cf11e7381eb9dadd2f6ed40e7ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_property.html">virtual</a> <a class="el" href="class_ogre_1_1_property.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_metal_hardware_index_buffer.html#a2f914cf11e7381eb9dadd2f6ed40e7ff">writeData</a> (<a class="el" href="class_ogre_1_1_property.html">size_t</a> offset, <a class="el" href="class_ogre_1_1_property.html">size_t</a> length, <a class="el" href="class_ogre_1_1_property.html">const</a> <a class="el" href="class_ogre_1_1_property.html">void</a> *<a class="el" href="class_ogre_1_1_property.html">pSource</a>, <a class="el" href="class_ogre_1_1_property.html">bool</a> <a class="el" href="class_ogre_1_1_property.html">discardWholeBuffer</a>=<a class="el" href="class_ogre_1_1_property.html">false</a>)</td></tr>
<tr class="memdesc:a2f914cf11e7381eb9dadd2f6ed40e7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to the buffer from an area of system memory; note that you must ensure that your buffer is big enough.  <br /></td></tr>
<tr class="separator:a2f914cf11e7381eb9dadd2f6ed40e7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a99816df51f0f9df30bf05ba8cdad0268" id="r_a99816df51f0f9df30bf05ba8cdad0268"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_property.html">static</a> <a class="el" href="class_ogre_1_1_property.html">const</a> <a class="el" href="group___general.html#ga496e620c45a7855770e490d92611ad19">IndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_index_buffer.html#a99816df51f0f9df30bf05ba8cdad0268">IT_16BIT</a> = Ogre::IT_16BIT</td></tr>
<tr class="separator:a99816df51f0f9df30bf05ba8cdad0268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a7bf368aa7c755fe7acd9fc936753c" id="r_ac9a7bf368aa7c755fe7acd9fc936753c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_property.html">static</a> <a class="el" href="class_ogre_1_1_property.html">const</a> <a class="el" href="group___general.html#ga496e620c45a7855770e490d92611ad19">IndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1v1_1_1_hardware_index_buffer.html#ac9a7bf368aa7c755fe7acd9fc936753c">IT_32BIT</a> = Ogre::IT_32BIT</td></tr>
<tr class="separator:ac9a7bf368aa7c755fe7acd9fc936753c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Specialisation of <a class="el" href="class_ogre_1_1v1_1_1_hardware_index_buffer.html" title="Specialisation of HardwareBuffer for vertex index buffers, still abstract.">HardwareIndexBuffer</a> for Metal. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a06f21d817782a7f95017e59581b9ddb5" name="a06f21d817782a7f95017e59581b9ddb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f21d817782a7f95017e59581b9ddb5">&#9670;&#160;</a></span>IndexType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_property.html">typedef</a> <a class="el" href="group___general.html#ga496e620c45a7855770e490d92611ad19">Ogre::IndexType</a> <a class="el" href="group___general.html#ga496e620c45a7855770e490d92611ad19">Ogre::v1::HardwareIndexBuffer::IndexType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ac0c56e93ce6f29bf39fb48c3d5dc64cf" name="ac0c56e93ce6f29bf39fb48c3d5dc64cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c56e93ce6f29bf39fb48c3d5dc64cf">&#9670;&#160;</a></span>LockOptions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_property.html">enum</a> <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#ac0c56e93ce6f29bf39fb48c3d5dc64cf">Ogre::v1::HardwareBuffer::LockOptions</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locking options. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac0c56e93ce6f29bf39fb48c3d5dc64cfaf32b55fa8a975d085b07236f89900f26" name="ac0c56e93ce6f29bf39fb48c3d5dc64cfaf32b55fa8a975d085b07236f89900f26"></a>HBL_NORMAL&#160;</td><td class="fielddoc"><p>Normal mode, ie allows read/write and contents are preserved. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac0c56e93ce6f29bf39fb48c3d5dc64cfa364f94b757045261468e68fe09c36cca" name="ac0c56e93ce6f29bf39fb48c3d5dc64cfa364f94b757045261468e68fe09c36cca"></a>HBL_DISCARD&#160;</td><td class="fielddoc"><p>Discards the <em>entire</em> buffer while locking; this allows optimisation to be performed because synchronisation issues are relaxed. </p>
<p>Only allowed on buffers created with the HBU_DYNAMIC flag. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac0c56e93ce6f29bf39fb48c3d5dc64cfa688a3812b47db689eebdbfefca66df87" name="ac0c56e93ce6f29bf39fb48c3d5dc64cfa688a3812b47db689eebdbfefca66df87"></a>HBL_READ_ONLY&#160;</td><td class="fielddoc"><p>Lock the buffer for reading only. </p>
<p>Not allowed in buffers which are created with HBU_WRITE_ONLY. Mandatory on static buffers, i.e. those created without the HBU_DYNAMIC flag. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac0c56e93ce6f29bf39fb48c3d5dc64cfae160717b1f864d2d91aa2ba24ac38771" name="ac0c56e93ce6f29bf39fb48c3d5dc64cfae160717b1f864d2d91aa2ba24ac38771"></a>HBL_NO_OVERWRITE&#160;</td><td class="fielddoc"><p>As HBL_DISCARD, except the application guarantees not to overwrite any region of the buffer which has already been used in this frame, can allow some optimisation on some APIs. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac0c56e93ce6f29bf39fb48c3d5dc64cfaacdcbae3ae1ce82b2f4411df53a545cb" name="ac0c56e93ce6f29bf39fb48c3d5dc64cfaacdcbae3ae1ce82b2f4411df53a545cb"></a>HBL_WRITE_ONLY&#160;</td><td class="fielddoc"><p>Lock the buffer for writing only. </p>
</td></tr>
</table>

</div>
</div>
<a id="a87632db14ce9c10e113f1966c6a97c6d" name="a87632db14ce9c10e113f1966c6a97c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87632db14ce9c10e113f1966c6a97c6d">&#9670;&#160;</a></span>Usage</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_property.html">enum</a> <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a87632db14ce9c10e113f1966c6a97c6d">Ogre::v1::HardwareBuffer::Usage</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enums describing buffer usage; not mutually exclusive. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a87632db14ce9c10e113f1966c6a97c6da0c8055304cee698c19e3080e34202430" name="a87632db14ce9c10e113f1966c6a97c6da0c8055304cee698c19e3080e34202430"></a>HBU_STATIC&#160;</td><td class="fielddoc"><p>Static buffer which the application rarely modifies once created. </p>
<p>Modifying the contents of this buffer will involve a performance hit. </p>
</td></tr>
<tr><td class="fieldname"><a id="a87632db14ce9c10e113f1966c6a97c6da1de64eadc98dfb60e9dcdf7fe6287c09" name="a87632db14ce9c10e113f1966c6a97c6da1de64eadc98dfb60e9dcdf7fe6287c09"></a>HBU_DYNAMIC&#160;</td><td class="fielddoc"><p>Indicates the application would like to modify this buffer with the CPU fairly often. </p>
<p>Buffers created with this flag will typically end up in AGP memory rather than video memory. </p>
</td></tr>
<tr><td class="fieldname"><a id="a87632db14ce9c10e113f1966c6a97c6da905091fc68f6e649aaa4e4aa0d5002ad" name="a87632db14ce9c10e113f1966c6a97c6da905091fc68f6e649aaa4e4aa0d5002ad"></a>HBU_WRITE_ONLY&#160;</td><td class="fielddoc"><p>Indicates the application will never read the contents of the buffer back, it will only ever write data. </p>
<p>Locking a buffer with this flag will ALWAYS return a pointer to new, blank memory rather than the memory associated with the contents of the buffer; this avoids DMA stalls because you can write to a new memory area while the previous one is being used. </p>
</td></tr>
<tr><td class="fieldname"><a id="a87632db14ce9c10e113f1966c6a97c6dac13bff725acd9c2ba76d95b6c700d659" name="a87632db14ce9c10e113f1966c6a97c6dac13bff725acd9c2ba76d95b6c700d659"></a>HBU_DISCARDABLE&#160;</td><td class="fielddoc"><p>Indicates that the application will be refilling the contents of the buffer regularly (not just updating, but generating the contents from scratch), and therefore does not mind if the contents of the buffer are lost somehow and need to be recreated. </p>
<p>This allows and additional level of optimisation on the buffer. This option only really makes sense when combined with HBU_DYNAMIC_WRITE_ONLY. </p>
</td></tr>
<tr><td class="fieldname"><a id="a87632db14ce9c10e113f1966c6a97c6dab5fe6ef729ea615265721a10ff7d9e57" name="a87632db14ce9c10e113f1966c6a97c6dab5fe6ef729ea615265721a10ff7d9e57"></a>HBU_STATIC_WRITE_ONLY&#160;</td><td class="fielddoc"><p>Combination of HBU_STATIC and HBU_WRITE_ONLY. </p>
</td></tr>
<tr><td class="fieldname"><a id="a87632db14ce9c10e113f1966c6a97c6da951a42185ad1d0df6294822dedcafce7" name="a87632db14ce9c10e113f1966c6a97c6da951a42185ad1d0df6294822dedcafce7"></a>HBU_DYNAMIC_WRITE_ONLY&#160;</td><td class="fielddoc"><p>Combination of HBU_DYNAMIC and HBU_WRITE_ONLY. </p>
<p>If you use this, strongly consider using HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE instead if you update the entire contents of the buffer very regularly. </p>
</td></tr>
<tr><td class="fieldname"><a id="a87632db14ce9c10e113f1966c6a97c6da3756a6536dc4f8a6c3434b704537c0eb" name="a87632db14ce9c10e113f1966c6a97c6da3756a6536dc4f8a6c3434b704537c0eb"></a>HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE&#160;</td><td class="fielddoc"><p>Combination of HBU_DYNAMIC, HBU_WRITE_ONLY and HBU_DISCARDABLE. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aaa1cb211b252381c3cc2ae3e5fa7b51e" name="aaa1cb211b252381c3cc2ae3e5fa7b51e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa1cb211b252381c3cc2ae3e5fa7b51e">&#9670;&#160;</a></span>MetalHardwareIndexBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::v1::MetalHardwareIndexBuffer::MetalHardwareIndexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_metal_hardware_buffer_manager_base.html">MetalHardwareBufferManagerBase</a> *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___general.html#ga496e620c45a7855770e490d92611ad19">IndexType</a>&#160;</td>
          <td class="paramname"><em>idxType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">size_t</a>&#160;</td>
          <td class="paramname"><em>numIndexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a87632db14ce9c10e113f1966c6a97c6d">HardwareBuffer::Usage</a>&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">bool</a>&#160;</td>
          <td class="paramname"><em>useShadowBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acb54c4cb1733973849f4831092143abb" name="acb54c4cb1733973849f4831092143abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb54c4cb1733973849f4831092143abb">&#9670;&#160;</a></span>~MetalHardwareIndexBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_property.html">virtual</a> Ogre::v1::MetalHardwareIndexBuffer::~MetalHardwareIndexBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad22a293cd1ffef8144c1206c67a1b8c7" name="ad22a293cd1ffef8144c1206c67a1b8c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad22a293cd1ffef8144c1206c67a1b8c7">&#9670;&#160;</a></span>_notifyDeviceStalled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_property.html">void</a> Ogre::v1::MetalHardwareIndexBuffer::_notifyDeviceStalled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae56c77c33e3c0f9634dcfc9b900be955" name="ae56c77c33e3c0f9634dcfc9b900be955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae56c77c33e3c0f9634dcfc9b900be955">&#9670;&#160;</a></span>_updateFromShadow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_property.html">virtual</a> <a class="el" href="class_ogre_1_1_property.html">void</a> Ogre::v1::MetalHardwareIndexBuffer::_updateFromShadow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the real buffer from the shadow buffer, if required. </p>

<p>Reimplemented from <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a1a1a5e9fd1743fdd09d2b1cfa740bcd4">Ogre::v1::HardwareBuffer</a>.</p>

</div>
</div>
<a id="a5caebd4b5db7696029eb412351d7767f" name="a5caebd4b5db7696029eb412351d7767f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5caebd4b5db7696029eb412351d7767f">&#9670;&#160;</a></span>copyData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_property.html">virtual</a> <a class="el" href="class_ogre_1_1_property.html">void</a> Ogre::v1::HardwareBuffer::copyData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html">HardwareBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>srcBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy all data from another buffer into this one. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Normally these buffers should be of identical size, but if they're not, the routine will use the smallest of the two sizes. </dd></dl>

</div>
</div>
<a id="aefcabd6287c8c73859046db3b6899606" name="aefcabd6287c8c73859046db3b6899606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefcabd6287c8c73859046db3b6899606">&#9670;&#160;</a></span>copyData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_property.html">virtual</a> <a class="el" href="class_ogre_1_1_property.html">void</a> Ogre::v1::MetalHardwareIndexBuffer::copyData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html">HardwareBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>srcBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">size_t</a>&#160;</td>
          <td class="paramname"><em>srcOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">size_t</a>&#160;</td>
          <td class="paramname"><em>dstOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">size_t</a>&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">bool</a>&#160;</td>
          <td class="paramname"><em>discardWholeBuffer</em> = <code><a class="el" href="class_ogre_1_1_property.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy data from another buffer into this one. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Note that the source buffer must not be created with the usage HBU_WRITE_ONLY otherwise this will fail. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcBuffer</td><td>The buffer from which to read the copied data </td></tr>
    <tr><td class="paramname">srcOffset</td><td>Offset in the source buffer at which to start reading </td></tr>
    <tr><td class="paramname">dstOffset</td><td>Offset in the destination buffer to start writing </td></tr>
    <tr><td class="paramname">length</td><td>Length of the data to copy, in bytes. </td></tr>
    <tr><td class="paramname">discardWholeBuffer</td><td>If true, will discard the entire contents of this buffer before copying </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a4c89e8f3e555b5baf18bcae16d5fb8dd">Ogre::v1::HardwareBuffer</a>.</p>

</div>
</div>
<a id="a2ac7207feb85f1edb25bf43a69e36415" name="a2ac7207feb85f1edb25bf43a69e36415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac7207feb85f1edb25bf43a69e36415">&#9670;&#160;</a></span>getBufferName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id&lt; <a class="el" href="class_ogre_1_1_property.html">MTLBuffer</a> &gt; Ogre::v1::MetalHardwareIndexBuffer::getBufferName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>outOffset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the actual API buffer, but first sets mLastFrameUsed as we assume you're calling this function to use the buffer in the GPU.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outOffset</td><td>Out. Guaranteed to be written. Used by HBU_DISCARDABLE buffers which need an offset to the internal ring buffer we've allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The MTLBuffer in question.   </dd></dl>

</div>
</div>
<a id="a27e333e9e57208cd9770b814544725ac" name="a27e333e9e57208cd9770b814544725ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e333e9e57208cd9770b814544725ac">&#9670;&#160;</a></span>getBufferNameForGpuWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id&lt; <a class="el" href="class_ogre_1_1_property.html">MTLBuffer</a> &gt; Ogre::v1::MetalHardwareIndexBuffer::getBufferNameForGpuWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a36fe33b74e8d2e3ce779026d264eb4b7" name="a36fe33b74e8d2e3ce779026d264eb4b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36fe33b74e8d2e3ce779026d264eb4b7">&#9670;&#160;</a></span>getIndexSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_property.html">size_t</a> Ogre::v1::HardwareIndexBuffer::getIndexSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size in bytes of each index. </p>

<p class="reference">Referenced by <a class="el" href="struct_ogre_1_1_vertices_remap_info.html#a56d6a14ebf2bd2dde0a81f191e7449c7">Ogre::VerticesRemapInfo::performIndexDataRemap()</a>.</p>

</div>
</div>
<a id="a76b05fc8856aa8aa9da03d026a3cc0a8" name="a76b05fc8856aa8aa9da03d026a3cc0a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b05fc8856aa8aa9da03d026a3cc0a8">&#9670;&#160;</a></span>getManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer_manager_base.html">HardwareBufferManagerBase</a> * Ogre::v1::HardwareIndexBuffer::getManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the manager of this buffer, if any. </p>

</div>
</div>
<a id="a428851931d37291897ec94487e621782" name="a428851931d37291897ec94487e621782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a428851931d37291897ec94487e621782">&#9670;&#160;</a></span>getNumIndexes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_property.html">size_t</a> Ogre::v1::HardwareIndexBuffer::getNumIndexes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of indexes in this buffer. </p>

</div>
</div>
<a id="a43cf91661a3183b399135646661d4e0f" name="a43cf91661a3183b399135646661d4e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43cf91661a3183b399135646661d4e0f">&#9670;&#160;</a></span>getRenderSystemData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_property.html">virtual</a> <a class="el" href="class_ogre_1_1_property.html">void</a> * Ogre::v1::MetalHardwareIndexBuffer::getRenderSystemData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An internal function that should be used only by a render system for internal use. </p>

<p>Reimplemented from <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#acd5391af42ed71d5338d23e7c7656e24">Ogre::v1::HardwareBuffer</a>.</p>

</div>
</div>
<a id="a6776e40af767f8db7d428f35d9b3055c" name="a6776e40af767f8db7d428f35d9b3055c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6776e40af767f8db7d428f35d9b3055c">&#9670;&#160;</a></span>getSizeInBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_property.html">size_t</a> Ogre::v1::HardwareBuffer::getSizeInBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of this buffer in bytes. </p>

</div>
</div>
<a id="aa8877417cc9443facdcc362be2fe72e2" name="aa8877417cc9443facdcc362be2fe72e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8877417cc9443facdcc362be2fe72e2">&#9670;&#160;</a></span>getType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___general.html#ga496e620c45a7855770e490d92611ad19">IndexType</a> Ogre::v1::HardwareIndexBuffer::getType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the type of indexes used in this buffer. </p>

<p class="reference">Referenced by <a class="el" href="struct_ogre_1_1_vertices_remap_info.html#a56d6a14ebf2bd2dde0a81f191e7449c7">Ogre::VerticesRemapInfo::performIndexDataRemap()</a>.</p>

</div>
</div>
<a id="a82d667c1abc2577fa7754ea44dd684b3" name="a82d667c1abc2577fa7754ea44dd684b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82d667c1abc2577fa7754ea44dd684b3">&#9670;&#160;</a></span>getUsage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a87632db14ce9c10e113f1966c6a97c6d">Usage</a> Ogre::v1::HardwareBuffer::getUsage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Usage flags with which this buffer was created. </p>

<p class="reference">Referenced by <a class="el" href="struct_ogre_1_1_vertices_remap_info.html#a56d6a14ebf2bd2dde0a81f191e7449c7">Ogre::VerticesRemapInfo::performIndexDataRemap()</a>.</p>

</div>
</div>
<a id="ae1e1ae8b6ec0a783e89e7c83e6aee49d" name="ae1e1ae8b6ec0a783e89e7c83e6aee49d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e1ae8b6ec0a783e89e7c83e6aee49d">&#9670;&#160;</a></span>hasShadowBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_property.html">bool</a> Ogre::v1::HardwareBuffer::hasShadowBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this buffer has a system memory shadow for quicker reading. </p>

<p class="reference">Referenced by <a class="el" href="struct_ogre_1_1_vertices_remap_info.html#a56d6a14ebf2bd2dde0a81f191e7449c7">Ogre::VerticesRemapInfo::performIndexDataRemap()</a>.</p>

</div>
</div>
<a id="ac9cbd2da85d59fe5ef6d5fa348052cd8" name="ac9cbd2da85d59fe5ef6d5fa348052cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9cbd2da85d59fe5ef6d5fa348052cd8">&#9670;&#160;</a></span>isLocked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_property.html">bool</a> Ogre::v1::HardwareBuffer::isLocked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this buffer is currently locked. </p>

<p class="reference">References <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#ac9cbd2da85d59fe5ef6d5fa348052cd8">Ogre::v1::HardwareBuffer::isLocked()</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#ac9cbd2da85d59fe5ef6d5fa348052cd8">Ogre::v1::HardwareBuffer::isLocked()</a>, and <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#ac20e63654b67a94b3836c52f9c81da99">Ogre::v1::HardwareBuffer::unlock()</a>.</p>

</div>
</div>
<a id="ac6d97282de4e5937ff00cf2ff14860a8" name="ac6d97282de4e5937ff00cf2ff14860a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d97282de4e5937ff00cf2ff14860a8">&#9670;&#160;</a></span>isSystemMemory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_property.html">bool</a> Ogre::v1::HardwareBuffer::isSystemMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this buffer is held in system memory. </p>

</div>
</div>
<a id="a15616b1645a8d88b0824b77a3cca3a78" name="a15616b1645a8d88b0824b77a3cca3a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15616b1645a8d88b0824b77a3cca3a78">&#9670;&#160;</a></span>lock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_property.html">void</a> * Ogre::v1::HardwareBuffer::lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#ac0c56e93ce6f29bf39fb48c3d5dc64cf">LockOptions</a>&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lock the entire buffer for (potentially) reading / writing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>Locking options </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the locked memory </dd></dl>

</div>
</div>
<a id="a31666db1708eb234e02e0c2cf4c7973b" name="a31666db1708eb234e02e0c2cf4c7973b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31666db1708eb234e02e0c2cf4c7973b">&#9670;&#160;</a></span>lock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_property.html">virtual</a> <a class="el" href="class_ogre_1_1_property.html">void</a> * Ogre::v1::HardwareBuffer::lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">size_t</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">size_t</a>&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#ac0c56e93ce6f29bf39fb48c3d5dc64cf">LockOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lock the buffer for (potentially) reading / writing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The byte offset from the start of the buffer to lock </td></tr>
    <tr><td class="paramname">length</td><td>The size of the area to lock, in bytes </td></tr>
    <tr><td class="paramname">options</td><td>Locking options </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the locked memory </dd></dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1v1_1_1_hardware_pixel_buffer.html#a31666db1708eb234e02e0c2cf4c7973b">Ogre::v1::HardwarePixelBuffer</a>, <a class="el" href="class_ogre_1_1v1_1_1_hardware_pixel_buffer.html#ad108795104afe2dd9062ac27c039b358">Ogre::v1::HardwarePixelBuffer</a>, <a class="el" href="class_ogre_1_1v1_1_1_default_hardware_vertex_buffer.html#acc3ddef7faca07103807ec07f0741f4c">Ogre::v1::DefaultHardwareVertexBuffer</a>, <a class="el" href="class_ogre_1_1v1_1_1_default_hardware_index_buffer.html#a59e04226073965da7b87778afe060ac2">Ogre::v1::DefaultHardwareIndexBuffer</a>, <a class="el" href="class_ogre_1_1v1_1_1_default_hardware_uniform_buffer.html#aa9301ec0b955da4ec345554f5e6f3f3e">Ogre::v1::DefaultHardwareUniformBuffer</a>, <a class="el" href="class_ogre_1_1v1_1_1_default_hardware_counter_buffer.html#a582e25674c50df2b7cb4494152aafddf">Ogre::v1::DefaultHardwareCounterBuffer</a>, <a class="el" href="class_ogre_1_1v1_1_1_d3_d11_hardware_index_buffer.html#a787b7538a62c51a9d650011955cf0ac5">Ogre::v1::D3D11HardwareIndexBuffer</a>, <a class="el" href="class_ogre_1_1v1_1_1_d3_d11_hardware_uniform_buffer.html#a81c30584a342151543a0b08eea719455">Ogre::v1::D3D11HardwareUniformBuffer</a>, <a class="el" href="class_ogre_1_1v1_1_1_d3_d11_hardware_vertex_buffer.html#a09e1a3e8da22a74e77c216872034d582">Ogre::v1::D3D11HardwareVertexBuffer</a>, <a class="el" href="class_ogre_1_1v1_1_1_g_l3_plus_default_hardware_vertex_buffer.html#aa4a800ecac0d89cd566f74ae55087db7">Ogre::v1::GL3PlusDefaultHardwareVertexBuffer</a>, <a class="el" href="class_ogre_1_1v1_1_1_g_l3_plus_default_hardware_index_buffer.html#acdc25c7a7f6b1387b3866ee3fe8ca488">Ogre::v1::GL3PlusDefaultHardwareIndexBuffer</a>, <a class="el" href="class_ogre_1_1v1_1_1_g_l3_plus_default_hardware_uniform_buffer.html#a3b463ac70cf06e49b30de1f213e35a10">Ogre::v1::GL3PlusDefaultHardwareUniformBuffer</a>, <a class="el" href="class_ogre_1_1v1_1_1_g_l3_plus_default_hardware_counter_buffer.html#adac59ffd3c55abf0b7ef06c2a3b34497">Ogre::v1::GL3PlusDefaultHardwareCounterBuffer</a>, <a class="el" href="class_ogre_1_1v1_1_1_g_l_e_s2_default_hardware_vertex_buffer.html#a60772b4c10d9e2dd9df39477d6907276">Ogre::v1::GLES2DefaultHardwareVertexBuffer</a>, <a class="el" href="class_ogre_1_1v1_1_1_g_l_e_s2_default_hardware_index_buffer.html#a1ec18b2eff6f59561275df88201a6542">Ogre::v1::GLES2DefaultHardwareIndexBuffer</a>, and <a class="el" href="class_ogre_1_1v1_1_1_g_l_e_s2_default_hardware_uniform_buffer.html#ace8554df242c584f728fe672a411aa26">Ogre::v1::GLES2DefaultHardwareUniformBuffer</a>.</p>

<p class="reference">References <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a31666db1708eb234e02e0c2cf4c7973b">Ogre::v1::HardwareBuffer::lock()</a>, and <a class="el" href="group___general.html#gaf27f0d64dfeb225d37a513c253eaa1a0">OGRE_EXCEPT</a>.</p>

<p class="reference">Referenced by <a class="el" href="struct_ogre_1_1v1_1_1_hardware_buffer_lock_guard.html#ab07f6e0c8362b3c487043177f42ed792">Ogre::v1::HardwareBufferLockGuard::lock()</a>, <a class="el" href="struct_ogre_1_1v1_1_1_hardware_buffer_lock_guard.html#a00823bfb4c23cdd19b630748d4a3cccb">Ogre::v1::HardwareBufferLockGuard::lock()</a>, and <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a31666db1708eb234e02e0c2cf4c7973b">Ogre::v1::HardwareBuffer::lock()</a>.</p>

</div>
</div>
<a id="a8357fe4fb4849772b94baa4bf47c7ded" name="a8357fe4fb4849772b94baa4bf47c7ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8357fe4fb4849772b94baa4bf47c7ded">&#9670;&#160;</a></span>operator delete() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="class_ogre_1_1_property.html">class</a> <a class="el" href="class_ogre_1_1_property.html">Alloc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_property.html">void</a> <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; <a class="el" href="class_ogre_1_1_property.html">Alloc</a> &gt;::operator <a class="el" href="class_ogre_1_1_property.html">delete</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">void</a> *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acb46d4b0a597156d9ba5abc39d127792" name="acb46d4b0a597156d9ba5abc39d127792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb46d4b0a597156d9ba5abc39d127792">&#9670;&#160;</a></span>operator delete() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="class_ogre_1_1_property.html">class</a> <a class="el" href="class_ogre_1_1_property.html">Alloc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_property.html">void</a> <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; <a class="el" href="class_ogre_1_1_property.html">Alloc</a> &gt;::operator <a class="el" href="class_ogre_1_1_property.html">delete</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">void</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">const</a> <a class="el" href="class_ogre_1_1_property.html">char</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">const</a> <a class="el" href="class_ogre_1_1_property.html">char</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c727e879a260c37b00ce5505fe8e144" name="a1c727e879a260c37b00ce5505fe8e144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c727e879a260c37b00ce5505fe8e144">&#9670;&#160;</a></span>operator delete() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="class_ogre_1_1_property.html">class</a> <a class="el" href="class_ogre_1_1_property.html">Alloc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_property.html">void</a> <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; <a class="el" href="class_ogre_1_1_property.html">Alloc</a> &gt;::operator <a class="el" href="class_ogre_1_1_property.html">delete</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">void</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">void</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93e6a86dde5483c053ca0f2a85bbfd6c" name="a93e6a86dde5483c053ca0f2a85bbfd6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e6a86dde5483c053ca0f2a85bbfd6c">&#9670;&#160;</a></span>operator delete[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="class_ogre_1_1_property.html">class</a> <a class="el" href="class_ogre_1_1_property.html">Alloc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_property.html">void</a> <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; <a class="el" href="class_ogre_1_1_property.html">Alloc</a> &gt;::operator <a class="el" href="class_ogre_1_1_property.html">delete</a>[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">void</a> *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a595ea4c05da8aa987d3800e65d23355d" name="a595ea4c05da8aa987d3800e65d23355d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595ea4c05da8aa987d3800e65d23355d">&#9670;&#160;</a></span>operator delete[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="class_ogre_1_1_property.html">class</a> <a class="el" href="class_ogre_1_1_property.html">Alloc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_property.html">void</a> <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; <a class="el" href="class_ogre_1_1_property.html">Alloc</a> &gt;::operator <a class="el" href="class_ogre_1_1_property.html">delete</a>[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">void</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">const</a> <a class="el" href="class_ogre_1_1_property.html">char</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">const</a> <a class="el" href="class_ogre_1_1_property.html">char</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1f1a983f9e2dfddee802c47bb0b1ca9" name="ad1f1a983f9e2dfddee802c47bb0b1ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f1a983f9e2dfddee802c47bb0b1ca9">&#9670;&#160;</a></span>operator new() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="class_ogre_1_1_property.html">class</a> <a class="el" href="class_ogre_1_1_property.html">Alloc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_property.html">void</a> * <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; <a class="el" href="class_ogre_1_1_property.html">Alloc</a> &gt;::operator <a class="el" href="class_ogre_1_1_property.html">new</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">size_t</a>&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab422c67a2c8844f410fe822a357cba3b" name="ab422c67a2c8844f410fe822a357cba3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab422c67a2c8844f410fe822a357cba3b">&#9670;&#160;</a></span>operator new() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="class_ogre_1_1_property.html">class</a> <a class="el" href="class_ogre_1_1_property.html">Alloc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_property.html">void</a> * <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; <a class="el" href="class_ogre_1_1_property.html">Alloc</a> &gt;::operator <a class="el" href="class_ogre_1_1_property.html">new</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">size_t</a>&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">const</a> <a class="el" href="class_ogre_1_1_property.html">char</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">int</a>&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">const</a> <a class="el" href="class_ogre_1_1_property.html">char</a> *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator new, with debug line info </p>

</div>
</div>
<a id="a63fc6bdc2eb6aeac24898a77ec5e2023" name="a63fc6bdc2eb6aeac24898a77ec5e2023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63fc6bdc2eb6aeac24898a77ec5e2023">&#9670;&#160;</a></span>operator new() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="class_ogre_1_1_property.html">class</a> <a class="el" href="class_ogre_1_1_property.html">Alloc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_property.html">void</a> * <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; <a class="el" href="class_ogre_1_1_property.html">Alloc</a> &gt;::operator <a class="el" href="class_ogre_1_1_property.html">new</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">size_t</a>&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">void</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>placement operator new </p>

</div>
</div>
<a id="adce32528577d71b228692df906ecd17c" name="adce32528577d71b228692df906ecd17c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce32528577d71b228692df906ecd17c">&#9670;&#160;</a></span>operator new[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="class_ogre_1_1_property.html">class</a> <a class="el" href="class_ogre_1_1_property.html">Alloc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_property.html">void</a> * <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; <a class="el" href="class_ogre_1_1_property.html">Alloc</a> &gt;::operator <a class="el" href="class_ogre_1_1_property.html">new</a>[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">size_t</a>&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aed1464ac3de21ff20db8f9f1f8608dc7" name="aed1464ac3de21ff20db8f9f1f8608dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed1464ac3de21ff20db8f9f1f8608dc7">&#9670;&#160;</a></span>operator new[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="class_ogre_1_1_property.html">class</a> <a class="el" href="class_ogre_1_1_property.html">Alloc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_property.html">void</a> * <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; <a class="el" href="class_ogre_1_1_property.html">Alloc</a> &gt;::operator <a class="el" href="class_ogre_1_1_property.html">new</a>[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">size_t</a>&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">const</a> <a class="el" href="class_ogre_1_1_property.html">char</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">int</a>&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">const</a> <a class="el" href="class_ogre_1_1_property.html">char</a> *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>array operator new, with debug line info </p>

</div>
</div>
<a id="a14766de5631308c2068c0e2510e7fe6f" name="a14766de5631308c2068c0e2510e7fe6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14766de5631308c2068c0e2510e7fe6f">&#9670;&#160;</a></span>readData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_property.html">virtual</a> <a class="el" href="class_ogre_1_1_property.html">void</a> Ogre::v1::MetalHardwareIndexBuffer::readData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">size_t</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">size_t</a>&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">void</a> *&#160;</td>
          <td class="paramname"><em>pDest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data from the buffer and places it in the memory pointed to by pDest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The byte offset from the start of the buffer to read </td></tr>
    <tr><td class="paramname">length</td><td>The size of the area to read, in bytes </td></tr>
    <tr><td class="paramname">pDest</td><td>The area of memory in which to place the data, must be large enough to accommodate the data! </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#a19c89711b1b819388d454bedee62efda">Ogre::v1::HardwareBuffer</a>.</p>

</div>
</div>
<a id="a4674ce75bfc84fa7e6ac03a059f0dbb5" name="a4674ce75bfc84fa7e6ac03a059f0dbb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4674ce75bfc84fa7e6ac03a059f0dbb5">&#9670;&#160;</a></span>suppressHardwareUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_property.html">void</a> Ogre::v1::HardwareBuffer::suppressHardwareUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">bool</a>&#160;</td>
          <td class="paramname"><em>suppress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> true to suppress hardware upload of shadow buffer changes. </p>

</div>
</div>
<a id="ac20e63654b67a94b3836c52f9c81da99" name="ac20e63654b67a94b3836c52f9c81da99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac20e63654b67a94b3836c52f9c81da99">&#9670;&#160;</a></span>unlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_property.html">virtual</a> <a class="el" href="class_ogre_1_1_property.html">void</a> Ogre::v1::HardwareBuffer::unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the lock on this buffer. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Locking and unlocking a buffer can, in some rare circumstances such as switching video modes whilst the buffer is locked, corrupt the contents of a buffer. This is pretty rare, but if it occurs, this method will throw an exception, meaning you must re-upload the data. </dd></dl>
<dl class="section user"><dt></dt><dd>Note that using the 'read' and 'write' forms of updating the buffer does not suffer from this problem, so if you want to be 100% sure your data will not be lost, use the 'read' and 'write' forms instead. </dd></dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1v1_1_1_default_hardware_vertex_buffer.html#ab72e0054ed710352a8fb59d9c8f79d33">Ogre::v1::DefaultHardwareVertexBuffer</a>, <a class="el" href="class_ogre_1_1v1_1_1_default_hardware_index_buffer.html#a42caade4cc46f9afa8d7dd968ff8fe02">Ogre::v1::DefaultHardwareIndexBuffer</a>, <a class="el" href="class_ogre_1_1v1_1_1_default_hardware_uniform_buffer.html#ad30a9be5ace64f16e2a0f3cc547d5cf1">Ogre::v1::DefaultHardwareUniformBuffer</a>, <a class="el" href="class_ogre_1_1v1_1_1_default_hardware_counter_buffer.html#a80cde1ab5ca8a79d91fe8ff87ada8197">Ogre::v1::DefaultHardwareCounterBuffer</a>, <a class="el" href="class_ogre_1_1v1_1_1_d3_d11_hardware_index_buffer.html#ad84536477c1d84ac169b899f9ff70221">Ogre::v1::D3D11HardwareIndexBuffer</a>, <a class="el" href="class_ogre_1_1v1_1_1_d3_d11_hardware_uniform_buffer.html#a6d7775dcf816cde3da927163765010c2">Ogre::v1::D3D11HardwareUniformBuffer</a>, <a class="el" href="class_ogre_1_1v1_1_1_d3_d11_hardware_vertex_buffer.html#aa227fe126ca32ad14819ba8fae3a23b3">Ogre::v1::D3D11HardwareVertexBuffer</a>, <a class="el" href="class_ogre_1_1v1_1_1_g_l3_plus_default_hardware_vertex_buffer.html#a0cbdf81b5a51488f16284add3362502d">Ogre::v1::GL3PlusDefaultHardwareVertexBuffer</a>, <a class="el" href="class_ogre_1_1v1_1_1_g_l3_plus_default_hardware_index_buffer.html#a27a473e4b565bcea3969f869981dfa45">Ogre::v1::GL3PlusDefaultHardwareIndexBuffer</a>, <a class="el" href="class_ogre_1_1v1_1_1_g_l3_plus_default_hardware_uniform_buffer.html#a3f58d2ecae1b65e1793e20dbdadb2431">Ogre::v1::GL3PlusDefaultHardwareUniformBuffer</a>, <a class="el" href="class_ogre_1_1v1_1_1_g_l3_plus_default_hardware_counter_buffer.html#a61887d011495f5c237f44e055412eff8">Ogre::v1::GL3PlusDefaultHardwareCounterBuffer</a>, <a class="el" href="class_ogre_1_1v1_1_1_g_l_e_s2_default_hardware_vertex_buffer.html#afea230ccdaeaaa59faf2bdb10ff8bc16">Ogre::v1::GLES2DefaultHardwareVertexBuffer</a>, <a class="el" href="class_ogre_1_1v1_1_1_g_l_e_s2_default_hardware_index_buffer.html#a8e14dbe62ff2ce5f5043757fc757454e">Ogre::v1::GLES2DefaultHardwareIndexBuffer</a>, and <a class="el" href="class_ogre_1_1v1_1_1_g_l_e_s2_default_hardware_uniform_buffer.html#af486a00f455e22ae88a2f3626e4eb9cb">Ogre::v1::GLES2DefaultHardwareUniformBuffer</a>.</p>

<p class="reference">References <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#ac9cbd2da85d59fe5ef6d5fa348052cd8">Ogre::v1::HardwareBuffer::isLocked()</a>, and <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#ac20e63654b67a94b3836c52f9c81da99">Ogre::v1::HardwareBuffer::unlock()</a>.</p>

<p class="reference">Referenced by <a class="el" href="struct_ogre_1_1v1_1_1_hardware_buffer_lock_guard.html#abbb10eb66176e02e88c872330e780991">Ogre::v1::HardwareBufferLockGuard::unlock()</a>, and <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#ac20e63654b67a94b3836c52f9c81da99">Ogre::v1::HardwareBuffer::unlock()</a>.</p>

</div>
</div>
<a id="a2f914cf11e7381eb9dadd2f6ed40e7ff" name="a2f914cf11e7381eb9dadd2f6ed40e7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f914cf11e7381eb9dadd2f6ed40e7ff">&#9670;&#160;</a></span>writeData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_property.html">virtual</a> <a class="el" href="class_ogre_1_1_property.html">void</a> Ogre::v1::MetalHardwareIndexBuffer::writeData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">size_t</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">size_t</a>&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">const</a> <a class="el" href="class_ogre_1_1_property.html">void</a> *&#160;</td>
          <td class="paramname"><em>pSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_property.html">bool</a>&#160;</td>
          <td class="paramname"><em>discardWholeBuffer</em> = <code><a class="el" href="class_ogre_1_1_property.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes data to the buffer from an area of system memory; note that you must ensure that your buffer is big enough. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The byte offset from the start of the buffer to start writing </td></tr>
    <tr><td class="paramname">length</td><td>The size of the data to write to, in bytes </td></tr>
    <tr><td class="paramname">pSource</td><td>The source of the data to be written </td></tr>
    <tr><td class="paramname">discardWholeBuffer</td><td>If true, this allows the driver to discard the entire buffer when writing, such that DMA stalls can be avoided; use if you can. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_ogre_1_1v1_1_1_hardware_buffer.html#ae998a972e53f2d5a9931f34aea21df8c">Ogre::v1::HardwareBuffer</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a99816df51f0f9df30bf05ba8cdad0268" name="a99816df51f0f9df30bf05ba8cdad0268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99816df51f0f9df30bf05ba8cdad0268">&#9670;&#160;</a></span>IT_16BIT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_property.html">const</a> <a class="el" href="group___general.html#ga496e620c45a7855770e490d92611ad19">IndexType</a> Ogre::v1::HardwareIndexBuffer::IT_16BIT = Ogre::IT_16BIT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="struct_ogre_1_1_vertices_remap_info.html#a56d6a14ebf2bd2dde0a81f191e7449c7">Ogre::VerticesRemapInfo::performIndexDataRemap()</a>.</p>

</div>
</div>
<a id="ac9a7bf368aa7c755fe7acd9fc936753c" name="ac9a7bf368aa7c755fe7acd9fc936753c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9a7bf368aa7c755fe7acd9fc936753c">&#9670;&#160;</a></span>IT_32BIT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_property.html">const</a> <a class="el" href="group___general.html#ga496e620c45a7855770e490d92611ad19">IndexType</a> Ogre::v1::HardwareIndexBuffer::IT_32BIT = Ogre::IT_32BIT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="struct_ogre_1_1_vertices_remap_info.html#ab601cedf8a462b73ecfc7cef546ce143">Ogre::VerticesRemapInfo::markUsedIndices()</a>, and <a class="el" href="struct_ogre_1_1_vertices_remap_info.html#a56d6a14ebf2bd2dde0a81f191e7449c7">Ogre::VerticesRemapInfo::performIndexDataRemap()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_metal_hardware_index_buffer_8h.html">OgreMetalHardwareIndexBuffer.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="namespace_ogre_1_1v1.html">v1</a></li><li class="navelem"><a class="el" href="class_ogre_1_1v1_1_1_metal_hardware_index_buffer.html">MetalHardwareIndexBuffer</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
