<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Ogre::PixelUtil Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE<span id="projectnumber">&#160;2.3</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_ogre_1_1_pixel_util.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_ogre_1_1_pixel_util-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ogre::PixelUtil Class Reference<div class="ingroups"><a class="el" href="group___core.html">Core</a> &raquo; <a class="el" href="group___image.html">Image</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Some utility functions for packing and unpacking pixel data.  
 <a href="class_ogre_1_1_pixel_util.html#details">More...</a></p>

<p><code>#include &lt;OgrePixelFormat.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a39f2867341e5d3ff964aaf2e5a02224c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#a39f2867341e5d3ff964aaf2e5a02224c">bulkCompressedSubregion</a> (const <a class="el" href="class_ogre_1_1_pixel_box.html">PixelBox</a> &amp;src, const <a class="el" href="class_ogre_1_1_pixel_box.html">PixelBox</a> &amp;dst, const <a class="el" href="struct_ogre_1_1_box.html">Box</a> &amp;dstRegion)</td></tr>
<tr class="memdesc:a39f2867341e5d3ff964aaf2e5a02224c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplaces the binary compressed data from src into a subregion of dst.  <a href="class_ogre_1_1_pixel_util.html#a39f2867341e5d3ff964aaf2e5a02224c">More...</a><br /></td></tr>
<tr class="separator:a39f2867341e5d3ff964aaf2e5a02224c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6e459a0f92c0c8e6bf4f20ee3a771a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#a9f6e459a0f92c0c8e6bf4f20ee3a771a">bulkPixelConversion</a> (const <a class="el" href="class_ogre_1_1_pixel_box.html">PixelBox</a> &amp;src, const <a class="el" href="class_ogre_1_1_pixel_box.html">PixelBox</a> &amp;dst)</td></tr>
<tr class="memdesc:a9f6e459a0f92c0c8e6bf4f20ee3a771a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert pixels from one format to another.  <a href="class_ogre_1_1_pixel_util.html#a9f6e459a0f92c0c8e6bf4f20ee3a771a">More...</a><br /></td></tr>
<tr class="separator:a9f6e459a0f92c0c8e6bf4f20ee3a771a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cae4443af5f8feb1c2f4f0905277c34"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#a0cae4443af5f8feb1c2f4f0905277c34">bulkPixelConversion</a> (void *src, <a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> srcFormat, void *dst, <a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> dstFormat, unsigned int count)</td></tr>
<tr class="memdesc:a0cae4443af5f8feb1c2f4f0905277c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert consecutive pixels from one format to another.  <a href="class_ogre_1_1_pixel_util.html#a0cae4443af5f8feb1c2f4f0905277c34">More...</a><br /></td></tr>
<tr class="separator:a0cae4443af5f8feb1c2f4f0905277c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8f29c8c1181ba98e22e342169970fd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#a3d8f29c8c1181ba98e22e342169970fd">bulkPixelVerticalFlip</a> (const <a class="el" href="class_ogre_1_1_pixel_box.html">PixelBox</a> &amp;box)</td></tr>
<tr class="memdesc:a3d8f29c8c1181ba98e22e342169970fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips pixels inplace in vertical direction.  <a href="class_ogre_1_1_pixel_util.html#a3d8f29c8c1181ba98e22e342169970fd">More...</a><br /></td></tr>
<tr class="separator:a3d8f29c8c1181ba98e22e342169970fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27d6389824bcfe21185f6728af8974e"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#ad27d6389824bcfe21185f6728af8974e">calculateSizeBytes</a> (<a class="el" href="namespace_ogre.html#a3cf2f2fac12b86461c219d6c6e26ce97">uint32</a> width, <a class="el" href="namespace_ogre.html#a3cf2f2fac12b86461c219d6c6e26ce97">uint32</a> height, <a class="el" href="namespace_ogre.html#a3cf2f2fac12b86461c219d6c6e26ce97">uint32</a> depth, <a class="el" href="namespace_ogre.html#a3cf2f2fac12b86461c219d6c6e26ce97">uint32</a> slices, <a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> format, <a class="el" href="namespace_ogre.html#ac6b9b3c6ac342cb9bf996f1bf6a8f9ce">uint8</a> numMipmaps)</td></tr>
<tr class="memdesc:ad27d6389824bcfe21185f6728af8974e"><td class="mdescLeft">&#160;</td><td class="mdescRight">WARNING: numMipmaps includes the mip 0.  <a href="class_ogre_1_1_pixel_util.html#ad27d6389824bcfe21185f6728af8974e">More...</a><br /></td></tr>
<tr class="separator:ad27d6389824bcfe21185f6728af8974e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe531d3eabd46c52a860a16a3b779a3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#acbe531d3eabd46c52a860a16a3b779a3">convertForNormalMapping</a> (const <a class="el" href="class_ogre_1_1_pixel_box.html">PixelBox</a> &amp;src, const <a class="el" href="class_ogre_1_1_pixel_box.html">PixelBox</a> &amp;dst)</td></tr>
<tr class="memdesc:acbe531d3eabd46c52a860a16a3b779a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the input source to either PF_R8G8_SNORM or PF_BYTE_LA.  <a href="class_ogre_1_1_pixel_util.html#acbe531d3eabd46c52a860a16a3b779a3">More...</a><br /></td></tr>
<tr class="separator:acbe531d3eabd46c52a860a16a3b779a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91159ec54a34fca27ccc7621c9b6d957"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#a91159ec54a34fca27ccc7621c9b6d957">getBitDepths</a> (<a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> format, int rgba[4])</td></tr>
<tr class="memdesc:a91159ec54a34fca27ccc7621c9b6d957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the number of bits (RGBA) for a format.  <a href="class_ogre_1_1_pixel_util.html#a91159ec54a34fca27ccc7621c9b6d957">More...</a><br /></td></tr>
<tr class="separator:a91159ec54a34fca27ccc7621c9b6d957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc6dbbd70a1f24b18db99cb1d2dae5d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#a9fc6dbbd70a1f24b18db99cb1d2dae5d">getBitMasks</a> (<a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> format, <a class="el" href="namespace_ogre.html#aa24724a1ac3f163efcb6cb63aa2f6f83">uint64</a> rgba[4])</td></tr>
<tr class="memdesc:a9fc6dbbd70a1f24b18db99cb1d2dae5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the masks for the R, G, B and A component.  <a href="class_ogre_1_1_pixel_util.html#a9fc6dbbd70a1f24b18db99cb1d2dae5d">More...</a><br /></td></tr>
<tr class="separator:a9fc6dbbd70a1f24b18db99cb1d2dae5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd54e9abc204019624bf99bc8cdb3c1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#afbd54e9abc204019624bf99bc8cdb3c1">getBitShifts</a> (<a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> format, unsigned char rgba[4])</td></tr>
<tr class="memdesc:afbd54e9abc204019624bf99bc8cdb3c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the bit shifts for R, G, B and A component.  <a href="class_ogre_1_1_pixel_util.html#afbd54e9abc204019624bf99bc8cdb3c1">More...</a><br /></td></tr>
<tr class="separator:afbd54e9abc204019624bf99bc8cdb3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32443d01d6399f778fce913ca80b0eee"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#a32443d01d6399f778fce913ca80b0eee">getBNFExpressionOfPixelFormats</a> (bool accessibleOnly=false)</td></tr>
<tr class="memdesc:a32443d01d6399f778fce913ca80b0eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the BNF expression of the pixel-formats.  <a href="class_ogre_1_1_pixel_util.html#a32443d01d6399f778fce913ca80b0eee">More...</a><br /></td></tr>
<tr class="separator:a32443d01d6399f778fce913ca80b0eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81ba2514ca7f5a53c84bb515de2ade0"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#ae81ba2514ca7f5a53c84bb515de2ade0">getComponentCount</a> (<a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> fmt)</td></tr>
<tr class="memdesc:ae81ba2514ca7f5a53c84bb515de2ade0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the component count for a certain pixel format.  <a href="class_ogre_1_1_pixel_util.html#ae81ba2514ca7f5a53c84bb515de2ade0">More...</a><br /></td></tr>
<tr class="separator:ae81ba2514ca7f5a53c84bb515de2ade0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ebf73b3830df2e83d529e60fd8c385"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___image.html#gac8f59c884998d9f84d9ea4c66e4c29fe">PixelComponentType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#a90ebf73b3830df2e83d529e60fd8c385">getComponentType</a> (<a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> fmt)</td></tr>
<tr class="memdesc:a90ebf73b3830df2e83d529e60fd8c385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the component type for a certain pixel format.  <a href="class_ogre_1_1_pixel_util.html#a90ebf73b3830df2e83d529e60fd8c385">More...</a><br /></td></tr>
<tr class="separator:a90ebf73b3830df2e83d529e60fd8c385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd97e402f3bbd0a3f641b2cf4d5cdc3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespace_ogre.html#a3cf2f2fac12b86461c219d6c6e26ce97">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#a7dd97e402f3bbd0a3f641b2cf4d5cdc3">getCompressedBlockHeight</a> (<a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> format, bool apiStrict=true)</td></tr>
<tr class="memdesc:a7dd97e402f3bbd0a3f641b2cf4d5cdc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">@See getCompressedBlockWidth  <a href="class_ogre_1_1_pixel_util.html#a7dd97e402f3bbd0a3f641b2cf4d5cdc3">More...</a><br /></td></tr>
<tr class="separator:a7dd97e402f3bbd0a3f641b2cf4d5cdc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94435ebfdb2d57f9f0fb77137d42d329"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespace_ogre.html#a3cf2f2fac12b86461c219d6c6e26ce97">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#a94435ebfdb2d57f9f0fb77137d42d329">getCompressedBlockWidth</a> (<a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> format, bool apiStrict=true)</td></tr>
<tr class="memdesc:a94435ebfdb2d57f9f0fb77137d42d329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum width for block compressed schemes.  <a href="class_ogre_1_1_pixel_util.html#a94435ebfdb2d57f9f0fb77137d42d329">More...</a><br /></td></tr>
<tr class="separator:a94435ebfdb2d57f9f0fb77137d42d329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c13cd6390b11bc851c9e2ba1201f40"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#ae0c13cd6390b11bc851c9e2ba1201f40">getFlags</a> (<a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> format)</td></tr>
<tr class="memdesc:ae0c13cd6390b11bc851c9e2ba1201f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the property flags for this pixel format.  <a href="class_ogre_1_1_pixel_util.html#ae0c13cd6390b11bc851c9e2ba1201f40">More...</a><br /></td></tr>
<tr class="separator:ae0c13cd6390b11bc851c9e2ba1201f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae127c3e6145af784e7d2d3734681a75a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#ae127c3e6145af784e7d2d3734681a75a">getFormatForBitDepths</a> (<a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> fmt, <a class="el" href="namespace_ogre.html#af851e71354d841df7138f9877c6f5931">ushort</a> integerBits, <a class="el" href="namespace_ogre.html#af851e71354d841df7138f9877c6f5931">ushort</a> floatBits)</td></tr>
<tr class="memdesc:ae127c3e6145af784e7d2d3734681a75a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the similar format but acoording with given bit depths.  <a href="class_ogre_1_1_pixel_util.html#ae127c3e6145af784e7d2d3734681a75a">More...</a><br /></td></tr>
<tr class="separator:ae127c3e6145af784e7d2d3734681a75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601fd16392331e7ddce6bcc455b5729d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#a601fd16392331e7ddce6bcc455b5729d">getFormatFromName</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, bool accessibleOnly=false, bool caseSensitive=false)</td></tr>
<tr class="memdesc:a601fd16392331e7ddce6bcc455b5729d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the format from given name.  <a href="class_ogre_1_1_pixel_util.html#a601fd16392331e7ddce6bcc455b5729d">More...</a><br /></td></tr>
<tr class="separator:a601fd16392331e7ddce6bcc455b5729d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec27f7358f77fabc0c9e68ce35b5af69"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#aec27f7358f77fabc0c9e68ce35b5af69">getFormatName</a> (<a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> srcformat)</td></tr>
<tr class="memdesc:aec27f7358f77fabc0c9e68ce35b5af69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of an image format.  <a href="class_ogre_1_1_pixel_util.html#aec27f7358f77fabc0c9e68ce35b5af69">More...</a><br /></td></tr>
<tr class="separator:aec27f7358f77fabc0c9e68ce35b5af69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77eb3410a8d54be1245b440bea01ac27"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespace_ogre.html#ac6b9b3c6ac342cb9bf996f1bf6a8f9ce">uint8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#a77eb3410a8d54be1245b440bea01ac27">getMaxMipmapCount</a> (<a class="el" href="namespace_ogre.html#a3cf2f2fac12b86461c219d6c6e26ce97">uint32</a> maxResolution)</td></tr>
<tr class="memdesc:a77eb3410a8d54be1245b440bea01ac27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of mipmaps given the resolution e.g.  <a href="class_ogre_1_1_pixel_util.html#a77eb3410a8d54be1245b440bea01ac27">More...</a><br /></td></tr>
<tr class="separator:a77eb3410a8d54be1245b440bea01ac27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff946ff2d852db7eb850c31164e812ea"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespace_ogre.html#ac6b9b3c6ac342cb9bf996f1bf6a8f9ce">uint8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#aff946ff2d852db7eb850c31164e812ea">getMaxMipmapCount</a> (<a class="el" href="namespace_ogre.html#a3cf2f2fac12b86461c219d6c6e26ce97">uint32</a> width, <a class="el" href="namespace_ogre.html#a3cf2f2fac12b86461c219d6c6e26ce97">uint32</a> height)</td></tr>
<tr class="separator:aff946ff2d852db7eb850c31164e812ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2eb99dcaf73f5f8196733ad3f3c8958"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespace_ogre.html#ac6b9b3c6ac342cb9bf996f1bf6a8f9ce">uint8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#af2eb99dcaf73f5f8196733ad3f3c8958">getMaxMipmapCount</a> (<a class="el" href="namespace_ogre.html#a3cf2f2fac12b86461c219d6c6e26ce97">uint32</a> width, <a class="el" href="namespace_ogre.html#a3cf2f2fac12b86461c219d6c6e26ce97">uint32</a> height, <a class="el" href="namespace_ogre.html#a3cf2f2fac12b86461c219d6c6e26ce97">uint32</a> depth)</td></tr>
<tr class="separator:af2eb99dcaf73f5f8196733ad3f3c8958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865aa435b593756fe2d2bd2463a18199"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#a865aa435b593756fe2d2bd2463a18199">getMemorySize</a> (<a class="el" href="namespace_ogre.html#a3cf2f2fac12b86461c219d6c6e26ce97">uint32</a> width, <a class="el" href="namespace_ogre.html#a3cf2f2fac12b86461c219d6c6e26ce97">uint32</a> height, <a class="el" href="namespace_ogre.html#a3cf2f2fac12b86461c219d6c6e26ce97">uint32</a> depth, <a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> format)</td></tr>
<tr class="memdesc:a865aa435b593756fe2d2bd2463a18199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size in memory of a region with the given extents and pixel format with consecutive memory layout.  <a href="class_ogre_1_1_pixel_util.html#a865aa435b593756fe2d2bd2463a18199">More...</a><br /></td></tr>
<tr class="separator:a865aa435b593756fe2d2bd2463a18199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbc281fe64d9f70b3ce5e6d3011cafb"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#a1dbc281fe64d9f70b3ce5e6d3011cafb">getNumElemBits</a> (<a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> format)</td></tr>
<tr class="memdesc:a1dbc281fe64d9f70b3ce5e6d3011cafb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size in bits of an element of the given pixel format.  <a href="class_ogre_1_1_pixel_util.html#a1dbc281fe64d9f70b3ce5e6d3011cafb">More...</a><br /></td></tr>
<tr class="separator:a1dbc281fe64d9f70b3ce5e6d3011cafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e39ec27d40f044a058e6fef850a1fbe"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#a1e39ec27d40f044a058e6fef850a1fbe">getNumElemBytes</a> (<a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> format)</td></tr>
<tr class="memdesc:a1e39ec27d40f044a058e6fef850a1fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size in bytes of an element of the given pixel format.  <a href="class_ogre_1_1_pixel_util.html#a1e39ec27d40f044a058e6fef850a1fbe">More...</a><br /></td></tr>
<tr class="separator:a1e39ec27d40f044a058e6fef850a1fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e15a9f2c0dc1cba158755633574fbc7"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#a1e15a9f2c0dc1cba158755633574fbc7">hasAlpha</a> (<a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> format)</td></tr>
<tr class="memdesc:a1e15a9f2c0dc1cba158755633574fbc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut method to determine if the format has an alpha component.  <a href="class_ogre_1_1_pixel_util.html#a1e15a9f2c0dc1cba158755633574fbc7">More...</a><br /></td></tr>
<tr class="separator:a1e15a9f2c0dc1cba158755633574fbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9e6ac27e4a4cb2d890d322b3f12c8e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#a2a9e6ac27e4a4cb2d890d322b3f12c8e">isAccessible</a> (<a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> srcformat)</td></tr>
<tr class="memdesc:a2a9e6ac27e4a4cb2d890d322b3f12c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the format can be packed or unpacked with the <a class="el" href="class_ogre_1_1_pixel_util.html#a793a7ae2bb8edec89ab520958ac33f40" title="Pack a colour value to memory.">packColour()</a> and <a class="el" href="class_ogre_1_1_pixel_util.html#a9b90b16c6c5c8a9fefd42e06a1bd99dc" title="Unpack a colour value from memory.">unpackColour()</a> functions.  <a href="class_ogre_1_1_pixel_util.html#a2a9e6ac27e4a4cb2d890d322b3f12c8e">More...</a><br /></td></tr>
<tr class="separator:a2a9e6ac27e4a4cb2d890d322b3f12c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4fcce8523b25011939624bfe2572314"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#ac4fcce8523b25011939624bfe2572314">isCompressed</a> (<a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> format)</td></tr>
<tr class="memdesc:ac4fcce8523b25011939624bfe2572314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut method to determine if the format is compressed.  <a href="class_ogre_1_1_pixel_util.html#ac4fcce8523b25011939624bfe2572314">More...</a><br /></td></tr>
<tr class="separator:ac4fcce8523b25011939624bfe2572314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51407cd07e47f24263942453ee4f93af"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#a51407cd07e47f24263942453ee4f93af">isDepth</a> (<a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> format)</td></tr>
<tr class="memdesc:a51407cd07e47f24263942453ee4f93af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut method to determine if the format is a depth format.  <a href="class_ogre_1_1_pixel_util.html#a51407cd07e47f24263942453ee4f93af">More...</a><br /></td></tr>
<tr class="separator:a51407cd07e47f24263942453ee4f93af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478b8c3bbb3bc516f3a06524fc1d9f4b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#a478b8c3bbb3bc516f3a06524fc1d9f4b">isFloatingPoint</a> (<a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> format)</td></tr>
<tr class="memdesc:a478b8c3bbb3bc516f3a06524fc1d9f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut method to determine if the format is floating point.  <a href="class_ogre_1_1_pixel_util.html#a478b8c3bbb3bc516f3a06524fc1d9f4b">More...</a><br /></td></tr>
<tr class="separator:a478b8c3bbb3bc516f3a06524fc1d9f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cda0d2a6af4cce55af33eae0b743822"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#a1cda0d2a6af4cce55af33eae0b743822">isInteger</a> (<a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> format)</td></tr>
<tr class="memdesc:a1cda0d2a6af4cce55af33eae0b743822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut method to determine if the format is integer.  <a href="class_ogre_1_1_pixel_util.html#a1cda0d2a6af4cce55af33eae0b743822">More...</a><br /></td></tr>
<tr class="separator:a1cda0d2a6af4cce55af33eae0b743822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2ff8ebe2e05d6c0dc5ab725b294cf8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#a7e2ff8ebe2e05d6c0dc5ab725b294cf8">isLuminance</a> (<a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> format)</td></tr>
<tr class="memdesc:a7e2ff8ebe2e05d6c0dc5ab725b294cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut method to determine if the format is a luminance format.  <a href="class_ogre_1_1_pixel_util.html#a7e2ff8ebe2e05d6c0dc5ab725b294cf8">More...</a><br /></td></tr>
<tr class="separator:a7e2ff8ebe2e05d6c0dc5ab725b294cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a3f3c1e6b98b537ce6dfed949afa3c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#aa6a3f3c1e6b98b537ce6dfed949afa3c">isNativeEndian</a> (<a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> format)</td></tr>
<tr class="memdesc:aa6a3f3c1e6b98b537ce6dfed949afa3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut method to determine if the format is in native endian format.  <a href="class_ogre_1_1_pixel_util.html#aa6a3f3c1e6b98b537ce6dfed949afa3c">More...</a><br /></td></tr>
<tr class="separator:aa6a3f3c1e6b98b537ce6dfed949afa3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8f1f4de7db504bd9a6c781cca28a42"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#aca8f1f4de7db504bd9a6c781cca28a42">isSigned</a> (<a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> format)</td></tr>
<tr class="memdesc:aca8f1f4de7db504bd9a6c781cca28a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut method to determine if the format is signed.  <a href="class_ogre_1_1_pixel_util.html#aca8f1f4de7db504bd9a6c781cca28a42">More...</a><br /></td></tr>
<tr class="separator:aca8f1f4de7db504bd9a6c781cca28a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb83c9058ba34602be4e07e4d7ce1d2d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#acb83c9058ba34602be4e07e4d7ce1d2d">isValidExtent</a> (size_t width, size_t height, size_t depth, <a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> format)</td></tr>
<tr class="memdesc:acb83c9058ba34602be4e07e4d7ce1d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether a certain image extent is valid for this image format.  <a href="class_ogre_1_1_pixel_util.html#acb83c9058ba34602be4e07e4d7ce1d2d">More...</a><br /></td></tr>
<tr class="separator:acb83c9058ba34602be4e07e4d7ce1d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793a7ae2bb8edec89ab520958ac33f40"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#a793a7ae2bb8edec89ab520958ac33f40">packColour</a> (const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;colour, const <a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> pf, void *dest)</td></tr>
<tr class="memdesc:a793a7ae2bb8edec89ab520958ac33f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a colour value to memory.  <a href="class_ogre_1_1_pixel_util.html#a793a7ae2bb8edec89ab520958ac33f40">More...</a><br /></td></tr>
<tr class="separator:a793a7ae2bb8edec89ab520958ac33f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29490454e6327a0429d19533880f6e2c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#a29490454e6327a0429d19533880f6e2c">packColour</a> (const float r, const float g, const float b, const float a, const <a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> pf, void *dest)</td></tr>
<tr class="memdesc:a29490454e6327a0429d19533880f6e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a colour value to memory.  <a href="class_ogre_1_1_pixel_util.html#a29490454e6327a0429d19533880f6e2c">More...</a><br /></td></tr>
<tr class="separator:a29490454e6327a0429d19533880f6e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0658994fbf0337d455ac9aa74ee8084"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#af0658994fbf0337d455ac9aa74ee8084">packColour</a> (const <a class="el" href="namespace_ogre.html#ac6b9b3c6ac342cb9bf996f1bf6a8f9ce">uint8</a> r, const <a class="el" href="namespace_ogre.html#ac6b9b3c6ac342cb9bf996f1bf6a8f9ce">uint8</a> g, const <a class="el" href="namespace_ogre.html#ac6b9b3c6ac342cb9bf996f1bf6a8f9ce">uint8</a> b, const <a class="el" href="namespace_ogre.html#ac6b9b3c6ac342cb9bf996f1bf6a8f9ce">uint8</a> a, const <a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> pf, void *dest)</td></tr>
<tr class="memdesc:af0658994fbf0337d455ac9aa74ee8084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a colour value to memory.  <a href="class_ogre_1_1_pixel_util.html#af0658994fbf0337d455ac9aa74ee8084">More...</a><br /></td></tr>
<tr class="separator:af0658994fbf0337d455ac9aa74ee8084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b90b16c6c5c8a9fefd42e06a1bd99dc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#a9b90b16c6c5c8a9fefd42e06a1bd99dc">unpackColour</a> (<a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> *colour, <a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> pf, const void *src)</td></tr>
<tr class="memdesc:a9b90b16c6c5c8a9fefd42e06a1bd99dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a colour value from memory.  <a href="class_ogre_1_1_pixel_util.html#a9b90b16c6c5c8a9fefd42e06a1bd99dc">More...</a><br /></td></tr>
<tr class="separator:a9b90b16c6c5c8a9fefd42e06a1bd99dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1448ad9a222ed03918f2e94a057612c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#ae1448ad9a222ed03918f2e94a057612c">unpackColour</a> (float *r, float *g, float *b, float *a, <a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> pf, const void *src)</td></tr>
<tr class="memdesc:ae1448ad9a222ed03918f2e94a057612c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a colour value from memory.  <a href="class_ogre_1_1_pixel_util.html#ae1448ad9a222ed03918f2e94a057612c">More...</a><br /></td></tr>
<tr class="separator:ae1448ad9a222ed03918f2e94a057612c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6599a03e4d51ef96f373f47253e2b9e3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_pixel_util.html#a6599a03e4d51ef96f373f47253e2b9e3">unpackColour</a> (<a class="el" href="namespace_ogre.html#ac6b9b3c6ac342cb9bf996f1bf6a8f9ce">uint8</a> *r, <a class="el" href="namespace_ogre.html#ac6b9b3c6ac342cb9bf996f1bf6a8f9ce">uint8</a> *g, <a class="el" href="namespace_ogre.html#ac6b9b3c6ac342cb9bf996f1bf6a8f9ce">uint8</a> *b, <a class="el" href="namespace_ogre.html#ac6b9b3c6ac342cb9bf996f1bf6a8f9ce">uint8</a> *a, <a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> pf, const void *src)</td></tr>
<tr class="memdesc:a6599a03e4d51ef96f373f47253e2b9e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a colour value from memory.  <a href="class_ogre_1_1_pixel_util.html#a6599a03e4d51ef96f373f47253e2b9e3">More...</a><br /></td></tr>
<tr class="separator:a6599a03e4d51ef96f373f47253e2b9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Some utility functions for packing and unpacking pixel data. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a39f2867341e5d3ff964aaf2e5a02224c" name="a39f2867341e5d3ff964aaf2e5a02224c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39f2867341e5d3ff964aaf2e5a02224c">&#9670;&nbsp;</a></span>bulkCompressedSubregion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::PixelUtil::bulkCompressedSubregion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_pixel_box.html">PixelBox</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_pixel_box.html">PixelBox</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>dstRegion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emplaces the binary compressed data from src into a subregion of dst. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td><a class="el" href="class_ogre_1_1_pixel_box.html">PixelBox</a> containing the source pixels, pitches and format. Data must be consecutive </td></tr>
    <tr><td class="paramname">dst</td><td><a class="el" href="class_ogre_1_1_pixel_box.html">PixelBox</a> containing the destination pixels, pitches and format. Data must be consecutive </td></tr>
    <tr><td class="paramname">dstRegion</td><td>The region on dst where src will be emplaced. dstRegion's resolution must match that of src. dstRegion must be within dst's bounds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The source and destination must have the same the same format. </dd></dl>
<dl class="section user"><dt></dt><dd>Each compression format may enforce different requirements. Most notably the subregions' bounds must be aligned to a certain boundary (usually to multiples of 4). If these requirements aren't met, an exception will be thrown. </dd></dl>
<dl class="section user"><dt></dt><dd>Some formats (i.e. PVRTC) don't support subregions at all, and thus an exception will be thrown. </dd></dl>
<dl class="section user"><dt></dt><dd>@See getCompressedBlockWidth </dd></dl>

</div>
</div>
<a id="a9f6e459a0f92c0c8e6bf4f20ee3a771a" name="a9f6e459a0f92c0c8e6bf4f20ee3a771a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6e459a0f92c0c8e6bf4f20ee3a771a">&#9670;&nbsp;</a></span>bulkPixelConversion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::PixelUtil::bulkPixelConversion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_pixel_box.html">PixelBox</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_pixel_box.html">PixelBox</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert pixels from one format to another. </p>
<p >No dithering or filtering is being done. Converting from RGB to luminance takes the R channel. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td><a class="el" href="class_ogre_1_1_pixel_box.html">PixelBox</a> containing the source pixels, pitches and format </td></tr>
    <tr><td class="paramname">dst</td><td><a class="el" href="class_ogre_1_1_pixel_box.html">PixelBox</a> containing the destination pixels, pitches and format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The source and destination boxes must have the same dimensions. In case the source and destination format match, a plain copy is done. </dd></dl>

</div>
</div>
<a id="a0cae4443af5f8feb1c2f4f0905277c34" name="a0cae4443af5f8feb1c2f4f0905277c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cae4443af5f8feb1c2f4f0905277c34">&#9670;&nbsp;</a></span>bulkPixelConversion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::PixelUtil::bulkPixelConversion </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>srcFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>dstFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert consecutive pixels from one format to another. </p>
<p >No dithering or filtering is being done. Converting from RGB to luminance takes the R channel. In case the source and destination format match, just a copy is done. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Pointer to source region </td></tr>
    <tr><td class="paramname">srcFormat</td><td>Pixel format of source region </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to destination region </td></tr>
    <tr><td class="paramname">dstFormat</td><td>Pixel format of destination region </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d8f29c8c1181ba98e22e342169970fd" name="a3d8f29c8c1181ba98e22e342169970fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8f29c8c1181ba98e22e342169970fd">&#9670;&nbsp;</a></span>bulkPixelVerticalFlip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::PixelUtil::bulkPixelVerticalFlip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_pixel_box.html">PixelBox</a> &amp;&#160;</td>
          <td class="paramname"><em>box</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flips pixels inplace in vertical direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">box</td><td><a class="el" href="class_ogre_1_1_pixel_box.html">PixelBox</a> containing pixels, pitches and format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Non consecutive pixel boxes are supported. </dd></dl>

</div>
</div>
<a id="ad27d6389824bcfe21185f6728af8974e" name="ad27d6389824bcfe21185f6728af8974e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27d6389824bcfe21185f6728af8974e">&#9670;&nbsp;</a></span>calculateSizeBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t Ogre::PixelUtil::calculateSizeBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a3cf2f2fac12b86461c219d6c6e26ce97">uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a3cf2f2fac12b86461c219d6c6e26ce97">uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a3cf2f2fac12b86461c219d6c6e26ce97">uint32</a>&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a3cf2f2fac12b86461c219d6c6e26ce97">uint32</a>&#160;</td>
          <td class="paramname"><em>slices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#ac6b9b3c6ac342cb9bf996f1bf6a8f9ce">uint8</a>&#160;</td>
          <td class="paramname"><em>numMipmaps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WARNING: numMipmaps includes the mip 0. </p>
<p >That means numMipmaps &gt; 0, and that you should use texture-&gt;getNumMipmaps + 1u </p>

</div>
</div>
<a id="acbe531d3eabd46c52a860a16a3b779a3" name="acbe531d3eabd46c52a860a16a3b779a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe531d3eabd46c52a860a16a3b779a3">&#9670;&nbsp;</a></span>convertForNormalMapping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::PixelUtil::convertForNormalMapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_pixel_box.html">PixelBox</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_pixel_box.html">PixelBox</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the input source to either PF_R8G8_SNORM or PF_BYTE_LA. </p>
<p >dst must be one of either formats. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td><a class="el" href="class_ogre_1_1_pixel_box.html">PixelBox</a> containing the source pixels, pitches and format </td></tr>
    <tr><td class="paramname">dst</td><td><a class="el" href="class_ogre_1_1_pixel_box.html">PixelBox</a> containing the destination pixels, pitches and format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The source and destination boxes must have the same dimensions. </dd></dl>

</div>
</div>
<a id="a91159ec54a34fca27ccc7621c9b6d957" name="a91159ec54a34fca27ccc7621c9b6d957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91159ec54a34fca27ccc7621c9b6d957">&#9670;&nbsp;</a></span>getBitDepths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::PixelUtil::getBitDepths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rgba</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives the number of bits (RGBA) for a format. </p>
<p >See remarks. <br  />
 </p><dl class="section remark"><dt>Remarks</dt><dd>For non-colour formats (dxt, depth) this returns [0,0,0,0]. </dd></dl>

</div>
</div>
<a id="a9fc6dbbd70a1f24b18db99cb1d2dae5d" name="a9fc6dbbd70a1f24b18db99cb1d2dae5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc6dbbd70a1f24b18db99cb1d2dae5d">&#9670;&nbsp;</a></span>getBitMasks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::PixelUtil::getBitMasks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa24724a1ac3f163efcb6cb63aa2f6f83">uint64</a>&#160;</td>
          <td class="paramname"><em>rgba</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives the masks for the R, G, B and A component. </p>
<dl class="section note"><dt>Note</dt><dd>Only valid for native endian formats </dd></dl>

</div>
</div>
<a id="afbd54e9abc204019624bf99bc8cdb3c1" name="afbd54e9abc204019624bf99bc8cdb3c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbd54e9abc204019624bf99bc8cdb3c1">&#9670;&nbsp;</a></span>getBitShifts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::PixelUtil::getBitShifts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>rgba</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives the bit shifts for R, G, B and A component. </p>
<dl class="section note"><dt>Note</dt><dd>Only valid for native endian formats </dd></dl>

</div>
</div>
<a id="a32443d01d6399f778fce913ca80b0eee" name="a32443d01d6399f778fce913ca80b0eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32443d01d6399f778fce913ca80b0eee">&#9670;&nbsp;</a></span>getBNFExpressionOfPixelFormats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> Ogre::PixelUtil::getBNFExpressionOfPixelFormats </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>accessibleOnly</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the BNF expression of the pixel-formats. </p>
<dl class="section note"><dt>Note</dt><dd>The string returned by this function is intended to be used as a BNF expression to work with Compiler2Pass. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">accessibleOnly</td><td>If true, only accessible pixel format will take into account, otherwise all pixel formats list in PixelFormat enumeration will being returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string contains the BNF expression. </dd></dl>

</div>
</div>
<a id="ae81ba2514ca7f5a53c84bb515de2ade0" name="ae81ba2514ca7f5a53c84bb515de2ade0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae81ba2514ca7f5a53c84bb515de2ade0">&#9670;&nbsp;</a></span>getComponentCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t Ogre::PixelUtil::getComponentCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>fmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the component count for a certain pixel format. </p>
<p >Returns 3(no alpha) or 4 (has alpha) in case there is no clear component type like with compressed formats. </p>

</div>
</div>
<a id="a90ebf73b3830df2e83d529e60fd8c385" name="a90ebf73b3830df2e83d529e60fd8c385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ebf73b3830df2e83d529e60fd8c385">&#9670;&nbsp;</a></span>getComponentType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___image.html#gac8f59c884998d9f84d9ea4c66e4c29fe">PixelComponentType</a> Ogre::PixelUtil::getComponentType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>fmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the component type for a certain pixel format. </p>
<p >Returns PCT_BYTE in case there is no clear component type like with compressed formats. This is one of PCT_BYTE, PCT_SHORT, PCT_FLOAT16, PCT_FLOAT32. </p>

</div>
</div>
<a id="a7dd97e402f3bbd0a3f641b2cf4d5cdc3" name="a7dd97e402f3bbd0a3f641b2cf4d5cdc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd97e402f3bbd0a3f641b2cf4d5cdc3">&#9670;&nbsp;</a></span>getCompressedBlockHeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespace_ogre.html#a3cf2f2fac12b86461c219d6c6e26ce97">uint32</a> Ogre::PixelUtil::getCompressedBlockHeight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>apiStrict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>@See getCompressedBlockWidth </p>

</div>
</div>
<a id="a94435ebfdb2d57f9f0fb77137d42d329" name="a94435ebfdb2d57f9f0fb77137d42d329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94435ebfdb2d57f9f0fb77137d42d329">&#9670;&nbsp;</a></span>getCompressedBlockWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespace_ogre.html#a3cf2f2fac12b86461c219d6c6e26ce97">uint32</a> Ogre::PixelUtil::getCompressedBlockWidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>apiStrict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum width for block compressed schemes. </p>
<p >ie. DXT1 compresses in blocks of 4x4 pixels. A texture with a width of 2 is just padded to 4. When building UV atlases composed of already compressed data being stitched together, the block size is very important to know as the resolution of the individual textures must be a multiple of this size. </p><dl class="section remark"><dt>Remarks</dt><dd>If the format is not compressed, returns 1. </dd></dl>
<dl class="section user"><dt></dt><dd>The function can return a value of 0 (as happens with PVRTC &amp; ETC1 compression); this is because although they may compress in blocks (i.e. PVRTC uses a 4x4 or 8x4 block), this information is useless as the compression scheme doesn't have isolated blocks (modifying a single pixel can change the binary data of the entire stream) making it useless for subimage sampling or creating UV atlas. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>The format to query for. Can be compressed or not. </td></tr>
    <tr><td class="paramname">apiStrict</td><td>When true, obeys the rules of most APIs (i.e. ETC1 can't update subregions according to GLES specs). When false, becomes more practical if manipulating by hand (i.e. ETC1's subregions can be updated just fine by @bulkCompressedSubregion) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The width of compression block, in pixels. Can be 0 (see remarks). If format is not compressed, returns 1. </dd></dl>

</div>
</div>
<a id="ae0c13cd6390b11bc851c9e2ba1201f40" name="ae0c13cd6390b11bc851c9e2ba1201f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c13cd6390b11bc851c9e2ba1201f40">&#9670;&nbsp;</a></span>getFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int Ogre::PixelUtil::getFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the property flags for this pixel format. </p>
<dl class="section return"><dt>Returns</dt><dd>A bitfield combination of PFF_HASALPHA, PFF_ISCOMPRESSED, PFF_FLOAT, PFF_DEPTH, PFF_NATIVEENDIAN, PFF_LUMINANCE </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This replaces the separate functions for formatHasAlpha, formatIsFloat, ... </dd></dl>

</div>
</div>
<a id="ae127c3e6145af784e7d2d3734681a75a" name="ae127c3e6145af784e7d2d3734681a75a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae127c3e6145af784e7d2d3734681a75a">&#9670;&nbsp;</a></span>getFormatForBitDepths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> Ogre::PixelUtil::getFormatForBitDepths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#af851e71354d841df7138f9877c6f5931">ushort</a>&#160;</td>
          <td class="paramname"><em>integerBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#af851e71354d841df7138f9877c6f5931">ushort</a>&#160;</td>
          <td class="paramname"><em>floatBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the similar format but acoording with given bit depths. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmt</td><td>The original foamt. </td></tr>
    <tr><td class="paramname">integerBits</td><td>Preferred bit depth (pixel bits) for integer pixel format. Available values: 0, 16 and 32, where 0 (the default) means as it is. </td></tr>
    <tr><td class="paramname">floatBits</td><td>Preferred bit depth (channel bits) for float pixel format. Available values: 0, 16 and 32, where 0 (the default) means as it is. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The format that similar original format with bit depth according with preferred bit depth, or original format if no conversion occurring. </dd></dl>

</div>
</div>
<a id="a601fd16392331e7ddce6bcc455b5729d" name="a601fd16392331e7ddce6bcc455b5729d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601fd16392331e7ddce6bcc455b5729d">&#9670;&nbsp;</a></span>getFormatFromName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> Ogre::PixelUtil::getFormatFromName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>accessibleOnly</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>caseSensitive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the format from given name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The string of format name </td></tr>
    <tr><td class="paramname">accessibleOnly</td><td>If true, non-accessible format will treat as invalid format, otherwise, all supported format are valid. </td></tr>
    <tr><td class="paramname">caseSensitive</td><td>Should be set true if string match should use case sensitivity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The format match the format name, or PF_UNKNOWN if is invalid name. </dd></dl>

</div>
</div>
<a id="aec27f7358f77fabc0c9e68ce35b5af69" name="aec27f7358f77fabc0c9e68ce35b5af69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec27f7358f77fabc0c9e68ce35b5af69">&#9670;&nbsp;</a></span>getFormatName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> Ogre::PixelUtil::getFormatName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>srcformat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the name of an image format. </p>

</div>
</div>
<a id="a77eb3410a8d54be1245b440bea01ac27" name="a77eb3410a8d54be1245b440bea01ac27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77eb3410a8d54be1245b440bea01ac27">&#9670;&nbsp;</a></span>getMaxMipmapCount() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespace_ogre.html#ac6b9b3c6ac342cb9bf996f1bf6a8f9ce">uint8</a> Ogre::PixelUtil::getMaxMipmapCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a3cf2f2fac12b86461c219d6c6e26ce97">uint32</a>&#160;</td>
          <td class="paramname"><em>maxResolution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of mipmaps given the resolution e.g. </p>
<p >at 4x4 there's 2 mipmaps. At 1x1 there's 0 mipmaps. </p><dl class="section return"><dt>Returns</dt><dd>Mip count. </dd></dl>

</div>
</div>
<a id="aff946ff2d852db7eb850c31164e812ea" name="aff946ff2d852db7eb850c31164e812ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff946ff2d852db7eb850c31164e812ea">&#9670;&nbsp;</a></span>getMaxMipmapCount() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespace_ogre.html#ac6b9b3c6ac342cb9bf996f1bf6a8f9ce">uint8</a> Ogre::PixelUtil::getMaxMipmapCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a3cf2f2fac12b86461c219d6c6e26ce97">uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a3cf2f2fac12b86461c219d6c6e26ce97">uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af2eb99dcaf73f5f8196733ad3f3c8958" name="af2eb99dcaf73f5f8196733ad3f3c8958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2eb99dcaf73f5f8196733ad3f3c8958">&#9670;&nbsp;</a></span>getMaxMipmapCount() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespace_ogre.html#ac6b9b3c6ac342cb9bf996f1bf6a8f9ce">uint8</a> Ogre::PixelUtil::getMaxMipmapCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a3cf2f2fac12b86461c219d6c6e26ce97">uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a3cf2f2fac12b86461c219d6c6e26ce97">uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a3cf2f2fac12b86461c219d6c6e26ce97">uint32</a>&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a865aa435b593756fe2d2bd2463a18199" name="a865aa435b593756fe2d2bd2463a18199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865aa435b593756fe2d2bd2463a18199">&#9670;&nbsp;</a></span>getMemorySize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t Ogre::PixelUtil::getMemorySize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a3cf2f2fac12b86461c219d6c6e26ce97">uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a3cf2f2fac12b86461c219d6c6e26ce97">uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a3cf2f2fac12b86461c219d6c6e26ce97">uint32</a>&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size in memory of a region with the given extents and pixel format with consecutive memory layout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The width of the area </td></tr>
    <tr><td class="paramname">height</td><td>The height of the area </td></tr>
    <tr><td class="paramname">depth</td><td>The depth of the area </td></tr>
    <tr><td class="paramname">format</td><td>The format of the area </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size in bytes </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>In case that the format is non-compressed, this simply returns width*height*depth*PixelUtil::getNumElemBytes(format). In the compressed case, this does serious magic. </dd></dl>

</div>
</div>
<a id="a1dbc281fe64d9f70b3ce5e6d3011cafb" name="a1dbc281fe64d9f70b3ce5e6d3011cafb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dbc281fe64d9f70b3ce5e6d3011cafb">&#9670;&nbsp;</a></span>getNumElemBits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t Ogre::PixelUtil::getNumElemBits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size in bits of an element of the given pixel format. </p>
<dl class="section return"><dt>Returns</dt><dd>The size in bits of an element. See Remarks. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Passing PF_UNKNOWN will result in returning a size of 0 bits. </dd></dl>

</div>
</div>
<a id="a1e39ec27d40f044a058e6fef850a1fbe" name="a1e39ec27d40f044a058e6fef850a1fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e39ec27d40f044a058e6fef850a1fbe">&#9670;&nbsp;</a></span>getNumElemBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t Ogre::PixelUtil::getNumElemBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size in bytes of an element of the given pixel format. </p>
<dl class="section return"><dt>Returns</dt><dd>The size in bytes of an element. See Remarks. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Passing PF_UNKNOWN will result in returning a size of 0 bytes. </dd></dl>

</div>
</div>
<a id="a1e15a9f2c0dc1cba158755633574fbc7" name="a1e15a9f2c0dc1cba158755633574fbc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e15a9f2c0dc1cba158755633574fbc7">&#9670;&nbsp;</a></span>hasAlpha()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Ogre::PixelUtil::hasAlpha </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shortcut method to determine if the format has an alpha component. </p>

</div>
</div>
<a id="a2a9e6ac27e4a4cb2d890d322b3f12c8e" name="a2a9e6ac27e4a4cb2d890d322b3f12c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a9e6ac27e4a4cb2d890d322b3f12c8e">&#9670;&nbsp;</a></span>isAccessible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Ogre::PixelUtil::isAccessible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>srcformat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the format can be packed or unpacked with the <a class="el" href="class_ogre_1_1_pixel_util.html#a793a7ae2bb8edec89ab520958ac33f40" title="Pack a colour value to memory.">packColour()</a> and <a class="el" href="class_ogre_1_1_pixel_util.html#a9b90b16c6c5c8a9fefd42e06a1bd99dc" title="Unpack a colour value from memory.">unpackColour()</a> functions. </p>
<p >This is generally not true for compressed and depth formats as they are special. It can only be true for formats with a fixed element size. </p><dl class="section return"><dt>Returns</dt><dd>true if yes, otherwise false </dd></dl>

</div>
</div>
<a id="ac4fcce8523b25011939624bfe2572314" name="ac4fcce8523b25011939624bfe2572314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4fcce8523b25011939624bfe2572314">&#9670;&nbsp;</a></span>isCompressed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Ogre::PixelUtil::isCompressed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shortcut method to determine if the format is compressed. </p>

</div>
</div>
<a id="a51407cd07e47f24263942453ee4f93af" name="a51407cd07e47f24263942453ee4f93af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51407cd07e47f24263942453ee4f93af">&#9670;&nbsp;</a></span>isDepth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Ogre::PixelUtil::isDepth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shortcut method to determine if the format is a depth format. </p>

</div>
</div>
<a id="a478b8c3bbb3bc516f3a06524fc1d9f4b" name="a478b8c3bbb3bc516f3a06524fc1d9f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a478b8c3bbb3bc516f3a06524fc1d9f4b">&#9670;&nbsp;</a></span>isFloatingPoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Ogre::PixelUtil::isFloatingPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shortcut method to determine if the format is floating point. </p>

</div>
</div>
<a id="a1cda0d2a6af4cce55af33eae0b743822" name="a1cda0d2a6af4cce55af33eae0b743822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cda0d2a6af4cce55af33eae0b743822">&#9670;&nbsp;</a></span>isInteger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Ogre::PixelUtil::isInteger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shortcut method to determine if the format is integer. </p>

</div>
</div>
<a id="a7e2ff8ebe2e05d6c0dc5ab725b294cf8" name="a7e2ff8ebe2e05d6c0dc5ab725b294cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e2ff8ebe2e05d6c0dc5ab725b294cf8">&#9670;&nbsp;</a></span>isLuminance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Ogre::PixelUtil::isLuminance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shortcut method to determine if the format is a luminance format. </p>

</div>
</div>
<a id="aa6a3f3c1e6b98b537ce6dfed949afa3c" name="aa6a3f3c1e6b98b537ce6dfed949afa3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6a3f3c1e6b98b537ce6dfed949afa3c">&#9670;&nbsp;</a></span>isNativeEndian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Ogre::PixelUtil::isNativeEndian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shortcut method to determine if the format is in native endian format. </p>

</div>
</div>
<a id="aca8f1f4de7db504bd9a6c781cca28a42" name="aca8f1f4de7db504bd9a6c781cca28a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8f1f4de7db504bd9a6c781cca28a42">&#9670;&nbsp;</a></span>isSigned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Ogre::PixelUtil::isSigned </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shortcut method to determine if the format is signed. </p>

</div>
</div>
<a id="acb83c9058ba34602be4e07e4d7ce1d2d" name="acb83c9058ba34602be4e07e4d7ce1d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb83c9058ba34602be4e07e4d7ce1d2d">&#9670;&nbsp;</a></span>isValidExtent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Ogre::PixelUtil::isValidExtent </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether a certain image extent is valid for this image format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The width of the area </td></tr>
    <tr><td class="paramname">height</td><td>The height of the area </td></tr>
    <tr><td class="paramname">depth</td><td>The depth of the area </td></tr>
    <tr><td class="paramname">format</td><td>The format of the area </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>For non-compressed formats, this is always true. For DXT formats, only sizes with a width and height multiple of 4 and depth 1 are allowed. </dd></dl>

</div>
</div>
<a id="a793a7ae2bb8edec89ab520958ac33f40" name="a793a7ae2bb8edec89ab520958ac33f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a793a7ae2bb8edec89ab520958ac33f40">&#9670;&nbsp;</a></span>packColour() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::PixelUtil::packColour </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td>
          <td class="paramname"><em>colour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack a colour value to memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">colour</td><td>The colour </td></tr>
    <tr><td class="paramname">pf</td><td>Pixelformat in which to write the colour </td></tr>
    <tr><td class="paramname">dest</td><td>Destination memory location </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29490454e6327a0429d19533880f6e2c" name="a29490454e6327a0429d19533880f6e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29490454e6327a0429d19533880f6e2c">&#9670;&nbsp;</a></span>packColour() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::PixelUtil::packColour </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack a colour value to memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r,g,b,a</td><td>The four colour components, range 0.0f to 1.0f (an exception to this case exists for floating point pixel formats, which don't clamp to 0.0f..1.0f) </td></tr>
    <tr><td class="paramname">pf</td><td>Pixelformat in which to write the colour </td></tr>
    <tr><td class="paramname">dest</td><td>Destination memory location </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0658994fbf0337d455ac9aa74ee8084" name="af0658994fbf0337d455ac9aa74ee8084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0658994fbf0337d455ac9aa74ee8084">&#9670;&nbsp;</a></span>packColour() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::PixelUtil::packColour </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac6b9b3c6ac342cb9bf996f1bf6a8f9ce">uint8</a>&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac6b9b3c6ac342cb9bf996f1bf6a8f9ce">uint8</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac6b9b3c6ac342cb9bf996f1bf6a8f9ce">uint8</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#ac6b9b3c6ac342cb9bf996f1bf6a8f9ce">uint8</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack a colour value to memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r,g,b,a</td><td>The four colour components, range 0.0f to 1.0f (an exception to this case exists for floating point pixel formats, which don't clamp to 0.0f..1.0f) </td></tr>
    <tr><td class="paramname">pf</td><td>Pixelformat in which to write the colour </td></tr>
    <tr><td class="paramname">dest</td><td>Destination memory location </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b90b16c6c5c8a9fefd42e06a1bd99dc" name="a9b90b16c6c5c8a9fefd42e06a1bd99dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b90b16c6c5c8a9fefd42e06a1bd99dc">&#9670;&nbsp;</a></span>unpackColour() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::PixelUtil::unpackColour </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> *&#160;</td>
          <td class="paramname"><em>colour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack a colour value from memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">colour</td><td>The colour is returned here </td></tr>
    <tr><td class="paramname">pf</td><td>Pixelformat in which to read the colour </td></tr>
    <tr><td class="paramname">src</td><td>Source memory location </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1448ad9a222ed03918f2e94a057612c" name="ae1448ad9a222ed03918f2e94a057612c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1448ad9a222ed03918f2e94a057612c">&#9670;&nbsp;</a></span>unpackColour() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::PixelUtil::unpackColour </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack a colour value from memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The red channel is returned here (as float) </td></tr>
    <tr><td class="paramname">g</td><td>The blue channel is returned here (as float) </td></tr>
    <tr><td class="paramname">b</td><td>The green channel is returned here (as float) </td></tr>
    <tr><td class="paramname">a</td><td>The alpha channel is returned here (as float) </td></tr>
    <tr><td class="paramname">pf</td><td>Pixelformat in which to read the colour </td></tr>
    <tr><td class="paramname">src</td><td>Source memory location </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6599a03e4d51ef96f373f47253e2b9e3" name="a6599a03e4d51ef96f373f47253e2b9e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6599a03e4d51ef96f373f47253e2b9e3">&#9670;&nbsp;</a></span>unpackColour() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::PixelUtil::unpackColour </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#ac6b9b3c6ac342cb9bf996f1bf6a8f9ce">uint8</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#ac6b9b3c6ac342cb9bf996f1bf6a8f9ce">uint8</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#ac6b9b3c6ac342cb9bf996f1bf6a8f9ce">uint8</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#ac6b9b3c6ac342cb9bf996f1bf6a8f9ce">uint8</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___image.html#ga7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>pf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack a colour value from memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The red channel is returned here (as byte) </td></tr>
    <tr><td class="paramname">g</td><td>The blue channel is returned here (as byte) </td></tr>
    <tr><td class="paramname">b</td><td>The green channel is returned here (as byte) </td></tr>
    <tr><td class="paramname">a</td><td>The alpha channel is returned here (as byte) </td></tr>
    <tr><td class="paramname">pf</td><td>Pixelformat in which to read the colour </td></tr>
    <tr><td class="paramname">src</td><td>Source memory location </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function returns the colour components in 8 bit precision, this will lose precision when coming from PF_A2R10G10B10 or floating point formats. <br  />
 </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_pixel_format_8h.html">OgrePixelFormat.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_pixel_util.html">PixelUtil</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
</body>
</html>
