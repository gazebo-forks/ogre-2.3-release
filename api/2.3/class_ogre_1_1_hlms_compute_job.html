<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Ogre::HlmsComputeJob Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign">
   <div id="projectname">OGRE<span id="projectnumber">&#160;2.3</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_ogre_1_1_hlms_compute_job.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_ogre_1_1_hlms_compute_job-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ogre::HlmsComputeJob Class Reference<div class="ingroups"><a class="el" href="group___component.html">Component</a> &raquo; <a class="el" href="group___material.html">Material</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;OgreHlmsComputeJob.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::HlmsComputeJob:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_hlms_compute_job__inherit__graph.svg" width="288" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afe11bd546cf7315f4526488e7078cc7d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7d">Reason</a> { <br />
&#160;&#160;<a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7da2b732a317de0915527e291485ca42e82">Unknown</a>
, <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7da58fd07194714679ed3ba9857d7656f27">FromStorageToSysRam</a>
, <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7da058c0eecb9f3f188fccc4d0018bf337b">FromSysRamToStorage</a>
, <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7da55066351a26967068b944c2170e51af1">GainedResidency</a>
, <br />
&#160;&#160;<a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7da61729c4ae25807d6132d5bc46580ff3d">LostResidency</a>
, <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7dafbdd85981846de4423d48d1a0ff665e0">PoolTextureSlotChanged</a>
, <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7da218a4243be85ec9c989b777119d5ff47">ResidentToSysRamSync</a>
, <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7da4f559ca1853a24a28b40caae1acda604">MetadataCacheOutOfDate</a>
, <br />
&#160;&#160;<a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7da704ea118c7e9f0b1598b528bdcbe1b26">ExceptionThrown</a>
, <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7dae3eb70053cbf5401f22893cdb47f81a7">FsaaSettingAlteredByApi</a>
, <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7dad4d9c6e3b7755f38d8d5f003be100257">ReadyForRendering</a>
, <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7dabb2a61a0002ccca6afbde7588787e58e">Deleted</a>
<br />
 }</td></tr>
<tr class="separator:afe11bd546cf7315f4526488e7078cc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297b925576b81843bd963d67ec561fbd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a297b925576b81843bd963d67ec561fbd">ThreadGroupsBasedOn</a> { <a class="el" href="class_ogre_1_1_hlms_compute_job.html#a297b925576b81843bd963d67ec561fbda697e40abfad5bdecd362193e78cdbdaf">ThreadGroupsBasedOnNothing</a>
, <a class="el" href="class_ogre_1_1_hlms_compute_job.html#a297b925576b81843bd963d67ec561fbdac33b17a1bd51fc701513327b1dd34aee">ThreadGroupsBasedOnTexture</a>
, <a class="el" href="class_ogre_1_1_hlms_compute_job.html#a297b925576b81843bd963d67ec561fbda5a8e8159a04475a17cdff51380da79ee">ThreadGroupsBasedOnUav</a>
 }</td></tr>
<tr class="separator:a297b925576b81843bd963d67ec561fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa2f584f8a3a801d850b6e16533bb14c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#aa2f584f8a3a801d850b6e16533bb14c5">HlmsComputeJob</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> name, <a class="el" href="class_ogre_1_1_hlms.html">Hlms</a> *creator, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;sourceFilename, const <a class="el" href="group___general.html#ga0899c03496d3c25c6555889aa76a78db">StringVector</a> &amp;includedPieceFiles)</td></tr>
<tr class="separator:aa2f584f8a3a801d850b6e16533bb14c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824bf5717b6d72f11ad9772873044bcc"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a824bf5717b6d72f11ad9772873044bcc">~HlmsComputeJob</a> ()</td></tr>
<tr class="separator:a824bf5717b6d72f11ad9772873044bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f01509a37d8699f43f520833053a3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#ae1f01509a37d8699f43f520833053a3a">_calculateNumThreadGroupsBasedOnSetting</a> ()</td></tr>
<tr class="memdesc:ae1f01509a37d8699f43f520833053a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">INTERNAL USE.  <a href="class_ogre_1_1_hlms_compute_job.html#ae1f01509a37d8699f43f520833053a3a">More...</a><br /></td></tr>
<tr class="separator:ae1f01509a37d8699f43f520833053a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb31b7ba51f4780bd7dd70629b080015"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#aeb31b7ba51f4780bd7dd70629b080015">_getRawGlTexSlotStart</a> (void) const</td></tr>
<tr class="separator:aeb31b7ba51f4780bd7dd70629b080015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19dbeacce1cead5de442ffffde91d9a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_shader_params.html">ShaderParams</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a19dbeacce1cead5de442ffffde91d9a5">_getShaderParams</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> key)</td></tr>
<tr class="memdesc:a19dbeacce1cead5de442ffffde91d9a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a shader parameter with the given key.  <a href="class_ogre_1_1_hlms_compute_job.html#a19dbeacce1cead5de442ffffde91d9a5">More...</a><br /></td></tr>
<tr class="separator:a19dbeacce1cead5de442ffffde91d9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e207a03438ec6db03d518cf32a3f73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a43e207a03438ec6db03d518cf32a3f73">_setSamplerblock</a> (<a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> slotIdx, const <a class="el" href="struct_ogre_1_1_hlms_samplerblock.html">HlmsSamplerblock</a> *refParams)</td></tr>
<tr class="memdesc:a43e207a03438ec6db03d518cf32a3f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a samplerblock directly.  <a href="class_ogre_1_1_hlms_compute_job.html#a43e207a03438ec6db03d518cf32a3f73">More...</a><br /></td></tr>
<tr class="separator:a43e207a03438ec6db03d518cf32a3f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e03115e7b8d1078d9ba2e300c14e6aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a6e03115e7b8d1078d9ba2e300c14e6aa">_setUavBuffer</a> (<a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> slotIdx, const <a class="el" href="struct_ogre_1_1_descriptor_set_uav_1_1_buffer_slot.html">DescriptorSetUav::BufferSlot</a> &amp;newSlot)</td></tr>
<tr class="memdesc:a6e03115e7b8d1078d9ba2e300c14e6aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an UAV buffer at the given slot ID.  <a href="class_ogre_1_1_hlms_compute_job.html#a6e03115e7b8d1078d9ba2e300c14e6aa">More...</a><br /></td></tr>
<tr class="separator:a6e03115e7b8d1078d9ba2e300c14e6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2622d6fe95f5d987feb888e6219c8d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#ab2622d6fe95f5d987feb888e6219c8d9">_setUavTexture</a> (<a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> slotIdx, const <a class="el" href="struct_ogre_1_1_descriptor_set_uav_1_1_texture_slot.html">DescriptorSetUav::TextureSlot</a> &amp;texSlot)</td></tr>
<tr class="memdesc:ab2622d6fe95f5d987feb888e6219c8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an UAV texture.  <a href="class_ogre_1_1_hlms_compute_job.html#ab2622d6fe95f5d987feb888e6219c8d9">More...</a><br /></td></tr>
<tr class="separator:ab2622d6fe95f5d987feb888e6219c8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8791e7cc76517dc3199245dc708875b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#ad8791e7cc76517dc3199245dc708875b">_updateAutoProperties</a> (void)</td></tr>
<tr class="separator:ad8791e7cc76517dc3199245dc708875b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85bb5fef35d0657a068ac24e38c656d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a85bb5fef35d0657a068ac24e38c656d1">analyzeBarriers</a> (<a class="el" href="group___resources.html#gab881163687bedff909edce16d11d9127">ResourceTransitionArray</a> &amp;resourceTransitions, bool clearBarriers=true)</td></tr>
<tr class="memdesc:a85bb5fef35d0657a068ac24e38c656d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks every regular texture and every UAV (texture and buffers) bound and resolves transitions.  <a href="class_ogre_1_1_hlms_compute_job.html#a85bb5fef35d0657a068ac24e38c656d1">More...</a><br /></td></tr>
<tr class="separator:a85bb5fef35d0657a068ac24e38c656d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252d4a14a71d6cda2ac43f9380a35563"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a252d4a14a71d6cda2ac43f9380a35563">clearTexBuffers</a> (void)</td></tr>
<tr class="memdesc:a252d4a14a71d6cda2ac43f9380a35563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all texture buffers to nullptr.  <a href="class_ogre_1_1_hlms_compute_job.html#a252d4a14a71d6cda2ac43f9380a35563">More...</a><br /></td></tr>
<tr class="separator:a252d4a14a71d6cda2ac43f9380a35563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ee45bd7599e90576cbdc3814bc76a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a52ee45bd7599e90576cbdc3814bc76a1">clearUavBuffers</a> (void)</td></tr>
<tr class="memdesc:a52ee45bd7599e90576cbdc3814bc76a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all UAV buffers to nullptr.  <a href="class_ogre_1_1_hlms_compute_job.html#a52ee45bd7599e90576cbdc3814bc76a1">More...</a><br /></td></tr>
<tr class="separator:a52ee45bd7599e90576cbdc3814bc76a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4da5d564918e18319bfeb6aa64beea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_hlms_compute_job.html">HlmsComputeJob</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#abe4da5d564918e18319bfeb6aa64beea">clone</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;cloneName)</td></tr>
<tr class="separator:abe4da5d564918e18319bfeb6aa64beea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63a38b43354ffa974bb834c3a156bc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#ab63a38b43354ffa974bb834c3a156bc9">cloneTo</a> (<a class="el" href="class_ogre_1_1_hlms_compute_job.html">HlmsComputeJob</a> *dstJob)</td></tr>
<tr class="separator:ab63a38b43354ffa974bb834c3a156bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb470bf33ca307f270a4d10bc07a4f61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#aeb470bf33ca307f270a4d10bc07a4f61">createShaderParams</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> key)</td></tr>
<tr class="memdesc:aeb470bf33ca307f270a4d10bc07a4f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a set of shader paramters with a given key, e.g.  <a href="class_ogre_1_1_hlms_compute_job.html#aeb470bf33ca307f270a4d10bc07a4f61">More...</a><br /></td></tr>
<tr class="separator:aeb470bf33ca307f270a4d10bc07a4f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260ffa4d1c79eb09cc51480f9c79b5b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_hlms.html">Hlms</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a260ffa4d1c79eb09cc51480f9c79b5b1">getCreator</a> (void) const</td></tr>
<tr class="separator:a260ffa4d1c79eb09cc51480f9c79b5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a79ed26036667b0a1f0e27b1e5c6ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#aa8a79ed26036667b0a1f0e27b1e5c6ee">getGlTexSlotStart</a> (void) const</td></tr>
<tr class="separator:aa8a79ed26036667b0a1f0e27b1e5c6ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11591653841ac96f3c46dcfd72e2e5e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a11591653841ac96f3c46dcfd72e2e5e9">getName</a> (void) const</td></tr>
<tr class="separator:a11591653841ac96f3c46dcfd72e2e5e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac605bf73c4444102ceb71b01249a7a90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#ac605bf73c4444102ceb71b01249a7a90">getNameStr</a> (void) const</td></tr>
<tr class="separator:ac605bf73c4444102ceb71b01249a7a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5111386e6bfd433aee3e7d75418f95c4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a5111386e6bfd433aee3e7d75418f95c4">getNumSamplerUnits</a> (void) const</td></tr>
<tr class="memdesc:a5111386e6bfd433aee3e7d75418f95c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">See setNumSamplerUnits.  <a href="class_ogre_1_1_hlms_compute_job.html#a5111386e6bfd433aee3e7d75418f95c4">More...</a><br /></td></tr>
<tr class="separator:a5111386e6bfd433aee3e7d75418f95c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7777cbf1ece29f3f4ab6d67291e6fb94"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a7777cbf1ece29f3f4ab6d67291e6fb94">getNumTexUnits</a> (void) const</td></tr>
<tr class="separator:a7777cbf1ece29f3f4ab6d67291e6fb94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1081ad0110411954dfc4c4ac232c93ac"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a1081ad0110411954dfc4c4ac232c93ac">getNumThreadGroups</a> (void) const</td></tr>
<tr class="separator:a1081ad0110411954dfc4c4ac232c93ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41730ed273c03f4b565d8152f26c526b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a41730ed273c03f4b565d8152f26c526b">getNumThreadGroupsX</a> (void) const</td></tr>
<tr class="separator:a41730ed273c03f4b565d8152f26c526b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91999971c1d8cff7eb0aa58f526c06e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a91999971c1d8cff7eb0aa58f526c06e5">getNumThreadGroupsY</a> (void) const</td></tr>
<tr class="separator:a91999971c1d8cff7eb0aa58f526c06e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24e21932fd29c779fb0457d77f355e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#aa24e21932fd29c779fb0457d77f355e7">getNumThreadGroupsZ</a> (void) const</td></tr>
<tr class="separator:aa24e21932fd29c779fb0457d77f355e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa511638c4bcef652bee3a7deef3b0ba"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#aaa511638c4bcef652bee3a7deef3b0ba">getNumUavUnits</a> (void) const</td></tr>
<tr class="separator:aaa511638c4bcef652bee3a7deef3b0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1219ae9a7aa15a300185a83f7af13ab7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#ae76a40e75ec4ec1c5261cb7d2804ccd3">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a1219ae9a7aa15a300185a83f7af13ab7">getProperty</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> key, <a class="el" href="namespace_ogre.html#ae76a40e75ec4ec1c5261cb7d2804ccd3">int32</a> defaultVal=0) const</td></tr>
<tr class="separator:a1219ae9a7aa15a300185a83f7af13ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa293ea88bddcaafa1d42618eaf668ecd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_shader_params.html">ShaderParams</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#aa293ea88bddcaafa1d42618eaf668ecd">getShaderParams</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> key)</td></tr>
<tr class="memdesc:aa293ea88bddcaafa1d42618eaf668ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a shader parameter with the given key.  <a href="class_ogre_1_1_hlms_compute_job.html#aa293ea88bddcaafa1d42618eaf668ecd">More...</a><br /></td></tr>
<tr class="separator:aa293ea88bddcaafa1d42618eaf668ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5eb96b2621980eae79f51c18d76435d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#ad5eb96b2621980eae79f51c18d76435d">getTexture</a> (<a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> slotIdx) const</td></tr>
<tr class="separator:ad5eb96b2621980eae79f51c18d76435d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb43253eda65f34470aa0a90993d5554"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#acb43253eda65f34470aa0a90993d5554">getThreadsPerGroup</a> (void) const</td></tr>
<tr class="separator:acb43253eda65f34470aa0a90993d5554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c3fd19134052c19082ebdd92d34f34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a10c3fd19134052c19082ebdd92d34f34">getThreadsPerGroupX</a> (void) const</td></tr>
<tr class="separator:a10c3fd19134052c19082ebdd92d34f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07afb5aedad54eecaf09ee9bf20fb537"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a07afb5aedad54eecaf09ee9bf20fb537">getThreadsPerGroupY</a> (void) const</td></tr>
<tr class="separator:a07afb5aedad54eecaf09ee9bf20fb537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9270ed547eb4ce0de7f59737ea99e6f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a9270ed547eb4ce0de7f59737ea99e6f5">getThreadsPerGroupZ</a> (void) const</td></tr>
<tr class="separator:a9270ed547eb4ce0de7f59737ea99e6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab137c32b77b7655aef6af11c7454bb47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#ab137c32b77b7655aef6af11c7454bb47">getUavBuffer</a> (<a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> slotIdx) const</td></tr>
<tr class="separator:ab137c32b77b7655aef6af11c7454bb47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd210342c2a32eb23a1e47172c3d73ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#acd210342c2a32eb23a1e47172c3d73ce">getUavTexture</a> (<a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> slotIdx) const</td></tr>
<tr class="separator:acd210342c2a32eb23a1e47172c3d73ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa56777d0419bdd6c0953b8756188cd9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#afa56777d0419bdd6c0953b8756188cd9">notifyTextureChanged</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture, <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7d">TextureGpuListener::Reason</a> reason, void *extraData)</td></tr>
<tr class="memdesc:afa56777d0419bdd6c0953b8756188cd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> changed in a way that affects how it is displayed:  <a href="class_ogre_1_1_hlms_compute_job.html#afa56777d0419bdd6c0953b8756188cd9">More...</a><br /></td></tr>
<tr class="separator:afa56777d0419bdd6c0953b8756188cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8357fe4fb4849772b94baa4bf47c7ded"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a8357fe4fb4849772b94baa4bf47c7ded">operator delete</a> (void *ptr)</td></tr>
<tr class="separator:a8357fe4fb4849772b94baa4bf47c7ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb46d4b0a597156d9ba5abc39d127792"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#acb46d4b0a597156d9ba5abc39d127792">operator delete</a> (void *ptr, const char *, int, const char *)</td></tr>
<tr class="separator:acb46d4b0a597156d9ba5abc39d127792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c727e879a260c37b00ce5505fe8e144"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a1c727e879a260c37b00ce5505fe8e144">operator delete</a> (void *ptr, void *)</td></tr>
<tr class="separator:a1c727e879a260c37b00ce5505fe8e144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e6a86dde5483c053ca0f2a85bbfd6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a93e6a86dde5483c053ca0f2a85bbfd6c">operator delete[]</a> (void *ptr)</td></tr>
<tr class="separator:a93e6a86dde5483c053ca0f2a85bbfd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595ea4c05da8aa987d3800e65d23355d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a595ea4c05da8aa987d3800e65d23355d">operator delete[]</a> (void *ptr, const char *, int, const char *)</td></tr>
<tr class="separator:a595ea4c05da8aa987d3800e65d23355d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f1a983f9e2dfddee802c47bb0b1ca9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#ad1f1a983f9e2dfddee802c47bb0b1ca9">operator new</a> (size_t sz)</td></tr>
<tr class="separator:ad1f1a983f9e2dfddee802c47bb0b1ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab422c67a2c8844f410fe822a357cba3b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#ab422c67a2c8844f410fe822a357cba3b">operator new</a> (size_t sz, const char *file, int line, const char *func)</td></tr>
<tr class="memdesc:ab422c67a2c8844f410fe822a357cba3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator new, with debug line info  <a href="class_ogre_1_1_allocated_object.html#ab422c67a2c8844f410fe822a357cba3b">More...</a><br /></td></tr>
<tr class="separator:ab422c67a2c8844f410fe822a357cba3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63fc6bdc2eb6aeac24898a77ec5e2023"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#a63fc6bdc2eb6aeac24898a77ec5e2023">operator new</a> (size_t sz, void *ptr)</td></tr>
<tr class="memdesc:a63fc6bdc2eb6aeac24898a77ec5e2023"><td class="mdescLeft">&#160;</td><td class="mdescRight">placement operator new  <a href="class_ogre_1_1_allocated_object.html#a63fc6bdc2eb6aeac24898a77ec5e2023">More...</a><br /></td></tr>
<tr class="separator:a63fc6bdc2eb6aeac24898a77ec5e2023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce32528577d71b228692df906ecd17c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#adce32528577d71b228692df906ecd17c">operator new[]</a> (size_t sz)</td></tr>
<tr class="separator:adce32528577d71b228692df906ecd17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1464ac3de21ff20db8f9f1f8608dc7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html#aed1464ac3de21ff20db8f9f1f8608dc7">operator new[]</a> (size_t sz, const char *file, int line, const char *func)</td></tr>
<tr class="memdesc:aed1464ac3de21ff20db8f9f1f8608dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">array operator new, with debug line info  <a href="class_ogre_1_1_allocated_object.html#aed1464ac3de21ff20db8f9f1f8608dc7">More...</a><br /></td></tr>
<tr class="separator:aed1464ac3de21ff20db8f9f1f8608dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb21babd61f9615f4ccd589278437e95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#abb21babd61f9615f4ccd589278437e95">removePiece</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> pieceName)</td></tr>
<tr class="memdesc:abb21babd61f9615f4ccd589278437e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an existing piece.  <a href="class_ogre_1_1_hlms_compute_job.html#abb21babd61f9615f4ccd589278437e95">More...</a><br /></td></tr>
<tr class="separator:abb21babd61f9615f4ccd589278437e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8057044899733d9a73ce7ddfd24d2bbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a8057044899733d9a73ce7ddfd24d2bbe">removeTexUnit</a> (<a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> slotIdx)</td></tr>
<tr class="memdesc:a8057044899733d9a73ce7ddfd24d2bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a given texture unit, displacing all the higher tex units.  <a href="class_ogre_1_1_hlms_compute_job.html#a8057044899733d9a73ce7ddfd24d2bbe">More...</a><br /></td></tr>
<tr class="separator:a8057044899733d9a73ce7ddfd24d2bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086ffb8324b45010f16fcc6f5314dedd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a086ffb8324b45010f16fcc6f5314dedd">removeUavUnit</a> (<a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> slotIdx)</td></tr>
<tr class="memdesc:a086ffb8324b45010f16fcc6f5314dedd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a given texture unit, displacing all the higher tex units.  <a href="class_ogre_1_1_hlms_compute_job.html#a086ffb8324b45010f16fcc6f5314dedd">More...</a><br /></td></tr>
<tr class="separator:a086ffb8324b45010f16fcc6f5314dedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27bc9875aa0f3a2f23d7a8c8e3a6e469"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a27bc9875aa0f3a2f23d7a8c8e3a6e469">setConstBuffer</a> (<a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> slotIdx, <a class="el" href="class_ogre_1_1_const_buffer_packed.html">ConstBufferPacked</a> *constBuffer)</td></tr>
<tr class="memdesc:a27bc9875aa0f3a2f23d7a8c8e3a6e469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a const/uniform bufferat the given slot ID.  <a href="class_ogre_1_1_hlms_compute_job.html#a27bc9875aa0f3a2f23d7a8c8e3a6e469">More...</a><br /></td></tr>
<tr class="separator:a27bc9875aa0f3a2f23d7a8c8e3a6e469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29709c020f2dbe9fd7bac1df927f5bc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a29709c020f2dbe9fd7bac1df927f5bc0">setGlTexSlotStart</a> (<a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> texSlotStart)</td></tr>
<tr class="memdesc:a29709c020f2dbe9fd7bac1df927f5bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">By default <a class="el" href="class_ogre_1_1_hlms_compute_job.html#ae8398ec1818d61b21005293c32173739" title="Sets a texture buffer at the given slot ID.">HlmsComputeJob::setTexture</a> and <a class="el" href="class_ogre_1_1_hlms_compute_job.html#ab6119b9bf4d187fcbcbb98e0988a09d2" title="Sets a texture buffer at the given slot ID.">HlmsComputeJob::setTexBuffer</a> are in range [0; getNumTexUnits)  <a href="class_ogre_1_1_hlms_compute_job.html#a29709c020f2dbe9fd7bac1df927f5bc0">More...</a><br /></td></tr>
<tr class="separator:a29709c020f2dbe9fd7bac1df927f5bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1aec87cba9ef66ee4b82267de4fb84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#aea1aec87cba9ef66ee4b82267de4fb84">setInformHlmsOfTextureData</a> (bool bInformHlms)</td></tr>
<tr class="memdesc:aea1aec87cba9ef66ee4b82267de4fb84"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="class_ogre_1_1_hlms.html" title="HLMS stands for &quot;High Level Material System&quot;.">Hlms</a> has the ability to pass data to the shader source code via its syntax system to add hardcoded values.  <a href="class_ogre_1_1_hlms_compute_job.html#aea1aec87cba9ef66ee4b82267de4fb84">More...</a><br /></td></tr>
<tr class="separator:aea1aec87cba9ef66ee4b82267de4fb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e88e59682a6c89874f6c19b1aa89f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a20e88e59682a6c89874f6c19b1aa89f9">setNumSamplerUnits</a> (<a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> numSlots)</td></tr>
<tr class="memdesc:a20e88e59682a6c89874f6c19b1aa89f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This value is overriden by setNumTexUnits to be compatible with OpenGL.  <a href="class_ogre_1_1_hlms_compute_job.html#a20e88e59682a6c89874f6c19b1aa89f9">More...</a><br /></td></tr>
<tr class="separator:a20e88e59682a6c89874f6c19b1aa89f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0998857be120bb37963c7cb593f9bfdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a0998857be120bb37963c7cb593f9bfdc">setNumTexUnits</a> (<a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> numSlots)</td></tr>
<tr class="memdesc:a0998857be120bb37963c7cb593f9bfdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates 'numSlots' number of slots before they can be set.  <a href="class_ogre_1_1_hlms_compute_job.html#a0998857be120bb37963c7cb593f9bfdc">More...</a><br /></td></tr>
<tr class="separator:a0998857be120bb37963c7cb593f9bfdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c6b47d60cba7f70ba182d1fc8d9d62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a80c6b47d60cba7f70ba182d1fc8d9d62">setNumThreadGroups</a> (<a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> numThreadGroupsX, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> numThreadGroupsY, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> numThreadGroupsZ)</td></tr>
<tr class="memdesc:a80c6b47d60cba7f70ba182d1fc8d9d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of groups of threads to dispatch.  <a href="class_ogre_1_1_hlms_compute_job.html#a80c6b47d60cba7f70ba182d1fc8d9d62">More...</a><br /></td></tr>
<tr class="separator:a80c6b47d60cba7f70ba182d1fc8d9d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad8078ce6528c5604e2a61bb516c000"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a7ad8078ce6528c5604e2a61bb516c000">setNumThreadGroupsBasedOn</a> (<a class="el" href="class_ogre_1_1_hlms_compute_job.html#a297b925576b81843bd963d67ec561fbd">ThreadGroupsBasedOn</a> source, <a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> texSlot, <a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> divisorX, <a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> divisorY, <a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> divisorZ)</td></tr>
<tr class="memdesc:a7ad8078ce6528c5604e2a61bb516c000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instead of calling setNumThreadGroups, <a class="el" href="namespace_ogre.html">Ogre</a> can automatically deduce them based on the <a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource.">Texture</a> resolution and the threads per group.  <a href="class_ogre_1_1_hlms_compute_job.html#a7ad8078ce6528c5604e2a61bb516c000">More...</a><br /></td></tr>
<tr class="separator:a7ad8078ce6528c5604e2a61bb516c000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8697f4897980adba72a42619fe6a463b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a8697f4897980adba72a42619fe6a463b">setNumUavUnits</a> (<a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> numSlots)</td></tr>
<tr class="memdesc:a8697f4897980adba72a42619fe6a463b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates 'numSlots' number of slots before they can be set.  <a href="class_ogre_1_1_hlms_compute_job.html#a8697f4897980adba72a42619fe6a463b">More...</a><br /></td></tr>
<tr class="separator:a8697f4897980adba72a42619fe6a463b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbb0de211ce8fd2ff8e0d9c869ecf90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#adcbb0de211ce8fd2ff8e0d9c869ecf90">setPiece</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> pieceName, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;pieceContent)</td></tr>
<tr class="memdesc:adcbb0de211ce8fd2ff8e0d9c869ecf90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a piece, i.e.  <a href="class_ogre_1_1_hlms_compute_job.html#adcbb0de211ce8fd2ff8e0d9c869ecf90">More...</a><br /></td></tr>
<tr class="separator:adcbb0de211ce8fd2ff8e0d9c869ecf90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b558bb23efecb99c9976312caff06c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a7b558bb23efecb99c9976312caff06c2">setProperty</a> (<a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> key, <a class="el" href="namespace_ogre.html#ae76a40e75ec4ec1c5261cb7d2804ccd3">int32</a> value)</td></tr>
<tr class="memdesc:a7b558bb23efecb99c9976312caff06c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an arbitrary property to pass to the shader.  <a href="class_ogre_1_1_hlms_compute_job.html#a7b558bb23efecb99c9976312caff06c2">More...</a><br /></td></tr>
<tr class="separator:a7b558bb23efecb99c9976312caff06c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708b1694992ac7ea73e3310fbb9b478b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a708b1694992ac7ea73e3310fbb9b478b">setSamplerblock</a> (<a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> slotIdx, const <a class="el" href="struct_ogre_1_1_hlms_samplerblock.html">HlmsSamplerblock</a> &amp;refParams)</td></tr>
<tr class="memdesc:a708b1694992ac7ea73e3310fbb9b478b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a samplerblock based on reference parameters.  <a href="class_ogre_1_1_hlms_compute_job.html#a708b1694992ac7ea73e3310fbb9b478b">More...</a><br /></td></tr>
<tr class="separator:a708b1694992ac7ea73e3310fbb9b478b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6119b9bf4d187fcbcbb98e0988a09d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#ab6119b9bf4d187fcbcbb98e0988a09d2">setTexBuffer</a> (<a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> slotIdx, const <a class="el" href="struct_ogre_1_1_descriptor_set_texture2_1_1_buffer_slot.html">DescriptorSetTexture2::BufferSlot</a> &amp;newSlot)</td></tr>
<tr class="memdesc:ab6119b9bf4d187fcbcbb98e0988a09d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a texture buffer at the given slot ID.  <a href="class_ogre_1_1_hlms_compute_job.html#ab6119b9bf4d187fcbcbb98e0988a09d2">More...</a><br /></td></tr>
<tr class="separator:ab6119b9bf4d187fcbcbb98e0988a09d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8398ec1818d61b21005293c32173739"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#ae8398ec1818d61b21005293c32173739">setTexture</a> (<a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> slotIdx, const <a class="el" href="struct_ogre_1_1_descriptor_set_texture2_1_1_texture_slot.html">DescriptorSetTexture2::TextureSlot</a> &amp;newSlot, const <a class="el" href="struct_ogre_1_1_hlms_samplerblock.html">HlmsSamplerblock</a> *refParams=0, bool bSetSampler=true)</td></tr>
<tr class="memdesc:ae8398ec1818d61b21005293c32173739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a texture buffer at the given slot ID.  <a href="class_ogre_1_1_hlms_compute_job.html#ae8398ec1818d61b21005293c32173739">More...</a><br /></td></tr>
<tr class="separator:ae8398ec1818d61b21005293c32173739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6c36a6b27927381afeea6965b148b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a1b6c36a6b27927381afeea6965b148b4">setThreadsPerGroup</a> (<a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> threadsPerGroupX, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> threadsPerGroupY, <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> threadsPerGroupZ)</td></tr>
<tr class="memdesc:a1b6c36a6b27927381afeea6965b148b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of threads per group.  <a href="class_ogre_1_1_hlms_compute_job.html#a1b6c36a6b27927381afeea6965b148b4">More...</a><br /></td></tr>
<tr class="separator:a1b6c36a6b27927381afeea6965b148b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18bf6a908f4f13fc8d0063a88bc0575"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#aa18bf6a908f4f13fc8d0063a88bc0575">setupRootLayout</a> (<a class="el" href="class_ogre_1_1_root_layout.html">RootLayout</a> &amp;rootLayout)</td></tr>
<tr class="separator:aa18bf6a908f4f13fc8d0063a88bc0575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1427f0b635a4186cd6083a9bab879fa2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_texture_gpu_listener.html#a1427f0b635a4186cd6083a9bab879fa2">shouldStayLoaded</a> (<a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *texture)</td></tr>
<tr class="memdesc:a1427f0b635a4186cd6083a9bab879fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> should likely stay loaded or else graphical changes could occur.  <a href="class_ogre_1_1_texture_gpu_listener.html#a1427f0b635a4186cd6083a9bab879fa2">More...</a><br /></td></tr>
<tr class="separator:a1427f0b635a4186cd6083a9bab879fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ae0a13b48d89c085d90419e793aa9c8b9"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#ae0a13b48d89c085d90419e793aa9c8b9">HlmsCompute</a></td></tr>
<tr class="separator:ae0a13b48d89c085d90419e793aa9c8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="afe11bd546cf7315f4526488e7078cc7d" name="afe11bd546cf7315f4526488e7078cc7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe11bd546cf7315f4526488e7078cc7d">&#9670;&nbsp;</a></span>Reason</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7d">Ogre::TextureGpuListener::Reason</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afe11bd546cf7315f4526488e7078cc7da2b732a317de0915527e291485ca42e82" name="afe11bd546cf7315f4526488e7078cc7da2b732a317de0915527e291485ca42e82"></a>Unknown&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afe11bd546cf7315f4526488e7078cc7da58fd07194714679ed3ba9857d7656f27" name="afe11bd546cf7315f4526488e7078cc7da58fd07194714679ed3ba9857d7656f27"></a>FromStorageToSysRam&#160;</td><td class="fielddoc"><p >OnStorage -&gt; OnSystemRam. </p>
</td></tr>
<tr><td class="fieldname"><a id="afe11bd546cf7315f4526488e7078cc7da058c0eecb9f3f188fccc4d0018bf337b" name="afe11bd546cf7315f4526488e7078cc7da058c0eecb9f3f188fccc4d0018bf337b"></a>FromSysRamToStorage&#160;</td><td class="fielddoc"><p >OnSystemRam -&gt; OnStorage. </p>
</td></tr>
<tr><td class="fieldname"><a id="afe11bd546cf7315f4526488e7078cc7da55066351a26967068b944c2170e51af1" name="afe11bd546cf7315f4526488e7078cc7da55066351a26967068b944c2170e51af1"></a>GainedResidency&#160;</td><td class="fielddoc"><p >OnStorage -&gt; Resident OnSystemRam -&gt; Resident See ReadyForRendering. </p>
</td></tr>
<tr><td class="fieldname"><a id="afe11bd546cf7315f4526488e7078cc7da61729c4ae25807d6132d5bc46580ff3d" name="afe11bd546cf7315f4526488e7078cc7da61729c4ae25807d6132d5bc46580ff3d"></a>LostResidency&#160;</td><td class="fielddoc"><p >Resident -&gt; OnStorage Resident -&gt; OnSystemRam. </p>
</td></tr>
<tr><td class="fieldname"><a id="afe11bd546cf7315f4526488e7078cc7dafbdd85981846de4423d48d1a0ff665e0" name="afe11bd546cf7315f4526488e7078cc7dafbdd85981846de4423d48d1a0ff665e0"></a>PoolTextureSlotChanged&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afe11bd546cf7315f4526488e7078cc7da218a4243be85ec9c989b777119d5ff47" name="afe11bd546cf7315f4526488e7078cc7da218a4243be85ec9c989b777119d5ff47"></a>ResidentToSysRamSync&#160;</td><td class="fielddoc"><p >Only called while <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> is still Resident, and strategy is AlwaysKeepSystemRamCopy. </p>
<p >This listener happens when something was done to the <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> that modifies its contents in the GPU, and were thus forced to sync those values back to SystemRam. This listener calls tells that sync is over. </p>
</td></tr>
<tr><td class="fieldname"><a id="afe11bd546cf7315f4526488e7078cc7da4f559ca1853a24a28b40caae1acda604" name="afe11bd546cf7315f4526488e7078cc7da4f559ca1853a24a28b40caae1acda604"></a>MetadataCacheOutOfDate&#160;</td><td class="fielddoc"><p >The Metadata cache was out of date and we had to do a ping-pong. </p>
<p >Expect this to be followed by at least LostResidency and GainedResidency calls</p>
<p >This is very important, because if you were expecting certain sequence of calls (e.g. you were expecting a LostResidency soon to arrive), expect that to be changed.</p>
<p >See <a class="el" href="class_ogre_1_1_texture_gpu_manager.html" title="This class manages all textures (i.e.">TextureGpuManager</a> for details about the metadata cache. </p>
</td></tr>
<tr><td class="fieldname"><a id="afe11bd546cf7315f4526488e7078cc7da704ea118c7e9f0b1598b528bdcbe1b26" name="afe11bd546cf7315f4526488e7078cc7da704ea118c7e9f0b1598b528bdcbe1b26"></a>ExceptionThrown&#160;</td><td class="fielddoc"><p >Called when the worker thread caught an exception. </p>
<p >This exception has already been logged, and the texture resumed loading normally with a white 2x2 RGBA8 fallback.</p>
<p >This listener will get called from the main thread.</p>
<p >The texture may still have pending residency transitions (e.g. it may still be loading the 2x2 fallback)</p>
<p >Cast <a class="el" href="class_ogre_1_1_exception.html" title="When thrown, provides information about an error that has occurred inside the engine.">Exception</a> <em>e = reinterpret_cast&lt;<a class="el" href="class_ogre_1_1_exception.html" title="When thrown, provides information about an error that has occurred inside the engine.">Exception</a></em>&gt;( extraData ); to know more info </p>
</td></tr>
<tr><td class="fieldname"><a id="afe11bd546cf7315f4526488e7078cc7dae3eb70053cbf5401f22893cdb47f81a7" name="afe11bd546cf7315f4526488e7078cc7dae3eb70053cbf5401f22893cdb47f81a7"></a>FsaaSettingAlteredByApi&#160;</td><td class="fielddoc"><p >Requested FSAA (MSAA / CSAA / EQAA / etc) is not supported by the API, and thus the setting had to be downgraded. </p>
<p >Note this may happen on device lost, and a new GPU became in use; thus it's possible for a <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> to initially support certain FSAA but later change. </p>
</td></tr>
<tr><td class="fieldname"><a id="afe11bd546cf7315f4526488e7078cc7dad4d9c6e3b7755f38d8d5f003be100257" name="afe11bd546cf7315f4526488e7078cc7dad4d9c6e3b7755f38d8d5f003be100257"></a>ReadyForRendering&#160;</td><td class="fielddoc"><p >This Reason is called when <a class="el" href="class_ogre_1_1_texture_gpu.html#abe10b3ea1bc20e616134af7b7f567446" title="Notifies it is safe to use the real data. Everything has been uploaded.">TextureGpu::notifyDataIsReady</a> is called. </p>
<p >This normally means worker thread is done loading texture from file and uploading it to GPU; and can now be used for rendering. It does NOT mean that <a class="el" href="namespace_ogre.html">Ogre</a> has finished issueing rendering commands to a <a class="el" href="class_ogre_1_1_render_texture.html" title="This class represents a RenderTarget that renders to a Texture.">RenderTexture</a> and is now ready to be presented to the monitor. </p>
</td></tr>
<tr><td class="fieldname"><a id="afe11bd546cf7315f4526488e7078cc7dabb2a61a0002ccca6afbde7588787e58e" name="afe11bd546cf7315f4526488e7078cc7dabb2a61a0002ccca6afbde7588787e58e"></a>Deleted&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a297b925576b81843bd963d67ec561fbd" name="a297b925576b81843bd963d67ec561fbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297b925576b81843bd963d67ec561fbd">&#9670;&nbsp;</a></span>ThreadGroupsBasedOn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_ogre_1_1_hlms_compute_job.html#a297b925576b81843bd963d67ec561fbd">Ogre::HlmsComputeJob::ThreadGroupsBasedOn</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a297b925576b81843bd963d67ec561fbda697e40abfad5bdecd362193e78cdbdaf" name="a297b925576b81843bd963d67ec561fbda697e40abfad5bdecd362193e78cdbdaf"></a>ThreadGroupsBasedOnNothing&#160;</td><td class="fielddoc"><p >Disabled. (obey setNumThreadGroups) </p>
</td></tr>
<tr><td class="fieldname"><a id="a297b925576b81843bd963d67ec561fbdac33b17a1bd51fc701513327b1dd34aee" name="a297b925576b81843bd963d67ec561fbdac33b17a1bd51fc701513327b1dd34aee"></a>ThreadGroupsBasedOnTexture&#160;</td><td class="fielddoc"><p >Based the number of thread groups on a texture. See setNumThreadGroupsBasedOn. </p>
</td></tr>
<tr><td class="fieldname"><a id="a297b925576b81843bd963d67ec561fbda5a8e8159a04475a17cdff51380da79ee" name="a297b925576b81843bd963d67ec561fbda5a8e8159a04475a17cdff51380da79ee"></a>ThreadGroupsBasedOnUav&#160;</td><td class="fielddoc"><p >Based the number of thread groups on a UAV. See setNumThreadGroupsBasedOn. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa2f584f8a3a801d850b6e16533bb14c5" name="aa2f584f8a3a801d850b6e16533bb14c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f584f8a3a801d850b6e16533bb14c5">&#9670;&nbsp;</a></span>HlmsComputeJob()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::HlmsComputeJob::HlmsComputeJob </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hlms.html">Hlms</a> *&#160;</td>
          <td class="paramname"><em>creator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___general.html#ga0899c03496d3c25c6555889aa76a78db">StringVector</a> &amp;&#160;</td>
          <td class="paramname"><em>includedPieceFiles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a824bf5717b6d72f11ad9772873044bcc" name="a824bf5717b6d72f11ad9772873044bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824bf5717b6d72f11ad9772873044bcc">&#9670;&nbsp;</a></span>~HlmsComputeJob()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::HlmsComputeJob::~HlmsComputeJob </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae1f01509a37d8699f43f520833053a3a" name="ae1f01509a37d8699f43f520833053a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f01509a37d8699f43f520833053a3a">&#9670;&nbsp;</a></span>_calculateNumThreadGroupsBasedOnSetting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::_calculateNumThreadGroupsBasedOnSetting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>INTERNAL USE. </p>
<p >Calculates the number of thread groups as specified in setNumThreadGroupsBasedOn, overriding setNumThreadGroups. </p>

</div>
</div>
<a id="aeb31b7ba51f4780bd7dd70629b080015" name="aeb31b7ba51f4780bd7dd70629b080015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb31b7ba51f4780bd7dd70629b080015">&#9670;&nbsp;</a></span>_getRawGlTexSlotStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> Ogre::HlmsComputeJob::_getRawGlTexSlotStart </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a19dbeacce1cead5de442ffffde91d9a5" name="a19dbeacce1cead5de442ffffde91d9a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19dbeacce1cead5de442ffffde91d9a5">&#9670;&nbsp;</a></span>_getShaderParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_shader_params.html">ShaderParams</a> * Ogre::HlmsComputeJob::_getShaderParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a shader parameter with the given key. </p>
<p >e.g. "default" "glsl" "hlsl". Returns null if doesn't exist. See createShaderParams </p>

</div>
</div>
<a id="a43e207a03438ec6db03d518cf32a3f73" name="a43e207a03438ec6db03d518cf32a3f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e207a03438ec6db03d518cf32a3f73">&#9670;&nbsp;</a></span>_setSamplerblock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::_setSamplerblock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_hlms_samplerblock.html">HlmsSamplerblock</a> *&#160;</td>
          <td class="paramname"><em>refParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a samplerblock directly. </p>
<p >For internal use / advanced users. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slotIdx</td><td>See setNumTexUnits.</td></tr>
  </table>
  </dd>
</dl>
<p>Must be in range [0; getNumTexUnits) regardless of what getTexSlotStart is </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">refParams</td><td>Direct samplerblock. Reference count is assumed to already have been increased. We won't increase it ourselves. </td></tr>
    <tr><td class="paramname">params</td><td>The sampler block to use as reference. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e03115e7b8d1078d9ba2e300c14e6aa" name="a6e03115e7b8d1078d9ba2e300c14e6aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e03115e7b8d1078d9ba2e300c14e6aa">&#9670;&nbsp;</a></span>_setUavBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::_setUavBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_descriptor_set_uav_1_1_buffer_slot.html">DescriptorSetUav::BufferSlot</a> &amp;&#160;</td>
          <td class="paramname"><em>newSlot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an UAV buffer at the given slot ID. </p>
<dl class="section remark"><dt>Remarks</dt><dd>UAV slots are shared with setUavTexture. Calling this function will remove the settings from previous setUavTexture calls to the same slot index. </dd></dl>
<dl class="section user"><dt></dt><dd>May trigger a recompilation if setInformHlmsOfTextureData is enabled. </dd></dl>
<dl class="section user"><dt></dt><dd>Be very careful when calling this directly. The Compositor needs to evaluate memory barriers and resource transitions. Leaving inconsistent memory barriers can result in hazards/race conditions in some APIs. If in doubt, change the <a class="el" href="class_ogre_1_1_compositor_pass_compute_def.html">CompositorPassComputeDef</a> instead. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slotIdx</td><td>See setNumUavUnits. The slot index to bind this UAV buffer. </td></tr>
    <tr><td class="paramname">newSlot</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2622d6fe95f5d987feb888e6219c8d9" name="ab2622d6fe95f5d987feb888e6219c8d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2622d6fe95f5d987feb888e6219c8d9">&#9670;&nbsp;</a></span>_setUavTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::_setUavTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_descriptor_set_uav_1_1_texture_slot.html">DescriptorSetUav::TextureSlot</a> &amp;&#160;</td>
          <td class="paramname"><em>texSlot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an UAV texture. </p>
<dl class="section remark"><dt>Remarks</dt><dd>UAV buffer slots are shared with setUavTexture's. Calling this function will remove the settings from previous setUavBuffer calls to the same slot index. </dd></dl>
<dl class="section user"><dt></dt><dd>May trigger a recompilation if setInformHlmsOfTextureData is enabled. </dd></dl>
<dl class="section user"><dt></dt><dd>Be very careful when calling this directly. The Compositor needs to evaluate memory barriers and resource transitions. Leaving inconsistent memory barriers can result in hazards/race conditions in some APIs. If in doubt, change the <a class="el" href="class_ogre_1_1_compositor_pass_compute_def.html">CompositorPassComputeDef</a> instead. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>See setNumUavUnits. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8791e7cc76517dc3199245dc708875b" name="ad8791e7cc76517dc3199245dc708875b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8791e7cc76517dc3199245dc708875b">&#9670;&nbsp;</a></span>_updateAutoProperties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::_updateAutoProperties </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a85bb5fef35d0657a068ac24e38c656d1" name="a85bb5fef35d0657a068ac24e38c656d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85bb5fef35d0657a068ac24e38c656d1">&#9670;&nbsp;</a></span>analyzeBarriers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::analyzeBarriers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___resources.html#gab881163687bedff909edce16d11d9127">ResourceTransitionArray</a> &amp;&#160;</td>
          <td class="paramname"><em>resourceTransitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clearBarriers</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks every regular texture and every UAV (texture and buffers) bound and resolves transitions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resourceTransitions</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a252d4a14a71d6cda2ac43f9380a35563" name="a252d4a14a71d6cda2ac43f9380a35563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252d4a14a71d6cda2ac43f9380a35563">&#9670;&nbsp;</a></span>clearTexBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::clearTexBuffers </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all texture buffers to nullptr. </p>

</div>
</div>
<a id="a52ee45bd7599e90576cbdc3814bc76a1" name="a52ee45bd7599e90576cbdc3814bc76a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ee45bd7599e90576cbdc3814bc76a1">&#9670;&nbsp;</a></span>clearUavBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::clearUavBuffers </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all UAV buffers to nullptr. </p>

</div>
</div>
<a id="abe4da5d564918e18319bfeb6aa64beea" name="abe4da5d564918e18319bfeb6aa64beea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4da5d564918e18319bfeb6aa64beea">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_hlms_compute_job.html">HlmsComputeJob</a> * Ogre::HlmsComputeJob::clone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab63a38b43354ffa974bb834c3a156bc9" name="ab63a38b43354ffa974bb834c3a156bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63a38b43354ffa974bb834c3a156bc9">&#9670;&nbsp;</a></span>cloneTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::cloneTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hlms_compute_job.html">HlmsComputeJob</a> *&#160;</td>
          <td class="paramname"><em>dstJob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb470bf33ca307f270a4d10bc07a4f61" name="aeb470bf33ca307f270a4d10bc07a4f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb470bf33ca307f270a4d10bc07a4f61">&#9670;&nbsp;</a></span>createShaderParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::createShaderParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a set of shader paramters with a given key, e.g. </p>
<p >"default" "glsl" "hlsl". Does nothing if parameters already exist. </p>

</div>
</div>
<a id="a260ffa4d1c79eb09cc51480f9c79b5b1" name="a260ffa4d1c79eb09cc51480f9c79b5b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a260ffa4d1c79eb09cc51480f9c79b5b1">&#9670;&nbsp;</a></span>getCreator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_hlms.html">Hlms</a> * Ogre::HlmsComputeJob::getCreator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8a79ed26036667b0a1f0e27b1e5c6ee" name="aa8a79ed26036667b0a1f0e27b1e5c6ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a79ed26036667b0a1f0e27b1e5c6ee">&#9670;&nbsp;</a></span>getGlTexSlotStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a> Ogre::HlmsComputeJob::getGlTexSlotStart </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a11591653841ac96f3c46dcfd72e2e5e9" name="a11591653841ac96f3c46dcfd72e2e5e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11591653841ac96f3c46dcfd72e2e5e9">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a> Ogre::HlmsComputeJob::getName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac605bf73c4444102ceb71b01249a7a90" name="ac605bf73c4444102ceb71b01249a7a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac605bf73c4444102ceb71b01249a7a90">&#9670;&nbsp;</a></span>getNameStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> Ogre::HlmsComputeJob::getNameStr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5111386e6bfd433aee3e7d75418f95c4" name="a5111386e6bfd433aee3e7d75418f95c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5111386e6bfd433aee3e7d75418f95c4">&#9670;&nbsp;</a></span>getNumSamplerUnits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::HlmsComputeJob::getNumSamplerUnits </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See setNumSamplerUnits. </p>

</div>
</div>
<a id="a7777cbf1ece29f3f4ab6d67291e6fb94" name="a7777cbf1ece29f3f4ab6d67291e6fb94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7777cbf1ece29f3f4ab6d67291e6fb94">&#9670;&nbsp;</a></span>getNumTexUnits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::HlmsComputeJob::getNumTexUnits </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1081ad0110411954dfc4c4ac232c93ac" name="a1081ad0110411954dfc4c4ac232c93ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1081ad0110411954dfc4c4ac232c93ac">&#9670;&nbsp;</a></span>getNumThreadGroups()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> * Ogre::HlmsComputeJob::getNumThreadGroups </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a41730ed273c03f4b565d8152f26c526b" name="a41730ed273c03f4b565d8152f26c526b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41730ed273c03f4b565d8152f26c526b">&#9670;&nbsp;</a></span>getNumThreadGroupsX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::HlmsComputeJob::getNumThreadGroupsX </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a91999971c1d8cff7eb0aa58f526c06e5" name="a91999971c1d8cff7eb0aa58f526c06e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91999971c1d8cff7eb0aa58f526c06e5">&#9670;&nbsp;</a></span>getNumThreadGroupsY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::HlmsComputeJob::getNumThreadGroupsY </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa24e21932fd29c779fb0457d77f355e7" name="aa24e21932fd29c779fb0457d77f355e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa24e21932fd29c779fb0457d77f355e7">&#9670;&nbsp;</a></span>getNumThreadGroupsZ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::HlmsComputeJob::getNumThreadGroupsZ </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa511638c4bcef652bee3a7deef3b0ba" name="aaa511638c4bcef652bee3a7deef3b0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa511638c4bcef652bee3a7deef3b0ba">&#9670;&nbsp;</a></span>getNumUavUnits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::HlmsComputeJob::getNumUavUnits </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1219ae9a7aa15a300185a83f7af13ab7" name="a1219ae9a7aa15a300185a83f7af13ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1219ae9a7aa15a300185a83f7af13ab7">&#9670;&nbsp;</a></span>getProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#ae76a40e75ec4ec1c5261cb7d2804ccd3">int32</a> Ogre::HlmsComputeJob::getProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#ae76a40e75ec4ec1c5261cb7d2804ccd3">int32</a>&#160;</td>
          <td class="paramname"><em>defaultVal</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa293ea88bddcaafa1d42618eaf668ecd" name="aa293ea88bddcaafa1d42618eaf668ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa293ea88bddcaafa1d42618eaf668ecd">&#9670;&nbsp;</a></span>getShaderParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_shader_params.html">ShaderParams</a> &amp; Ogre::HlmsComputeJob::getShaderParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a shader parameter with the given key. </p>
<p >e.g. "default" "glsl" "hlsl". Creates if does not exist. </p>

</div>
</div>
<a id="ad5eb96b2621980eae79f51c18d76435d" name="ad5eb96b2621980eae79f51c18d76435d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5eb96b2621980eae79f51c18d76435d">&#9670;&nbsp;</a></span>getTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> * Ogre::HlmsComputeJob::getTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acb43253eda65f34470aa0a90993d5554" name="acb43253eda65f34470aa0a90993d5554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb43253eda65f34470aa0a90993d5554">&#9670;&nbsp;</a></span>getThreadsPerGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> * Ogre::HlmsComputeJob::getThreadsPerGroup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a10c3fd19134052c19082ebdd92d34f34" name="a10c3fd19134052c19082ebdd92d34f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10c3fd19134052c19082ebdd92d34f34">&#9670;&nbsp;</a></span>getThreadsPerGroupX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::HlmsComputeJob::getThreadsPerGroupX </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a07afb5aedad54eecaf09ee9bf20fb537" name="a07afb5aedad54eecaf09ee9bf20fb537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07afb5aedad54eecaf09ee9bf20fb537">&#9670;&nbsp;</a></span>getThreadsPerGroupY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::HlmsComputeJob::getThreadsPerGroupY </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9270ed547eb4ce0de7f59737ea99e6f5" name="a9270ed547eb4ce0de7f59737ea99e6f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9270ed547eb4ce0de7f59737ea99e6f5">&#9670;&nbsp;</a></span>getThreadsPerGroupZ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a> Ogre::HlmsComputeJob::getThreadsPerGroupZ </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab137c32b77b7655aef6af11c7454bb47" name="ab137c32b77b7655aef6af11c7454bb47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab137c32b77b7655aef6af11c7454bb47">&#9670;&nbsp;</a></span>getUavBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_uav_buffer_packed.html">UavBufferPacked</a> * Ogre::HlmsComputeJob::getUavBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd210342c2a32eb23a1e47172c3d73ce" name="acd210342c2a32eb23a1e47172c3d73ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd210342c2a32eb23a1e47172c3d73ce">&#9670;&nbsp;</a></span>getUavTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> * Ogre::HlmsComputeJob::getUavTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afa56777d0419bdd6c0953b8756188cd9" name="afa56777d0419bdd6c0953b8756188cd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa56777d0419bdd6c0953b8756188cd9">&#9670;&nbsp;</a></span>notifyTextureChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::HlmsComputeJob::notifyTextureChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu_listener.html#afe11bd546cf7315f4526488e7078cc7d">TextureGpuListener::Reason</a>&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>extraData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when a <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> changed in a way that affects how it is displayed: </p>
<ol type="1">
<li><a class="el" href="class_ogre_1_1_texture_gpu.html#abe10b3ea1bc20e616134af7b7f567446" title="Notifies it is safe to use the real data. Everything has been uploaded.">TextureGpu::notifyDataIsReady</a> got called (texture is ready to be displayed)</li>
<li><a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource.">Texture</a> changed residency status.</li>
<li><a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource.">Texture</a> is being deleted. It won't be a valid pointer after this call. </li>
</ol>

<p>Implements <a class="el" href="class_ogre_1_1_texture_gpu_listener.html#aad4e9062c9a92d1e2cc57d4bbe50eb95">Ogre::TextureGpuListener</a>.</p>

</div>
</div>
<a id="a8357fe4fb4849772b94baa4bf47c7ded" name="a8357fe4fb4849772b94baa4bf47c7ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8357fe4fb4849772b94baa4bf47c7ded">&#9670;&nbsp;</a></span>operator delete() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acb46d4b0a597156d9ba5abc39d127792" name="acb46d4b0a597156d9ba5abc39d127792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb46d4b0a597156d9ba5abc39d127792">&#9670;&nbsp;</a></span>operator delete() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c727e879a260c37b00ce5505fe8e144" name="a1c727e879a260c37b00ce5505fe8e144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c727e879a260c37b00ce5505fe8e144">&#9670;&nbsp;</a></span>operator delete() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93e6a86dde5483c053ca0f2a85bbfd6c" name="a93e6a86dde5483c053ca0f2a85bbfd6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e6a86dde5483c053ca0f2a85bbfd6c">&#9670;&nbsp;</a></span>operator delete[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a595ea4c05da8aa987d3800e65d23355d" name="a595ea4c05da8aa987d3800e65d23355d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595ea4c05da8aa987d3800e65d23355d">&#9670;&nbsp;</a></span>operator delete[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1f1a983f9e2dfddee802c47bb0b1ca9" name="ad1f1a983f9e2dfddee802c47bb0b1ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f1a983f9e2dfddee802c47bb0b1ca9">&#9670;&nbsp;</a></span>operator new() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab422c67a2c8844f410fe822a357cba3b" name="ab422c67a2c8844f410fe822a357cba3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab422c67a2c8844f410fe822a357cba3b">&#9670;&nbsp;</a></span>operator new() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator new, with debug line info </p>

</div>
</div>
<a id="a63fc6bdc2eb6aeac24898a77ec5e2023" name="a63fc6bdc2eb6aeac24898a77ec5e2023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63fc6bdc2eb6aeac24898a77ec5e2023">&#9670;&nbsp;</a></span>operator new() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>placement operator new </p>

</div>
</div>
<a id="adce32528577d71b228692df906ecd17c" name="adce32528577d71b228692df906ecd17c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce32528577d71b228692df906ecd17c">&#9670;&nbsp;</a></span>operator new[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aed1464ac3de21ff20db8f9f1f8608dc7" name="aed1464ac3de21ff20db8f9f1f8608dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed1464ac3de21ff20db8f9f1f8608dc7">&#9670;&nbsp;</a></span>operator new[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>array operator new, with debug line info </p>

</div>
</div>
<a id="abb21babd61f9615f4ccd589278437e95" name="abb21babd61f9615f4ccd589278437e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb21babd61f9615f4ccd589278437e95">&#9670;&nbsp;</a></span>removePiece()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::removePiece </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>pieceName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes an existing piece. </p>
<p >See setPiece. Does nothing if the piece didn't exist. </p>

</div>
</div>
<a id="a8057044899733d9a73ce7ddfd24d2bbe" name="a8057044899733d9a73ce7ddfd24d2bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8057044899733d9a73ce7ddfd24d2bbe">&#9670;&nbsp;</a></span>removeTexUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::removeTexUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a given texture unit, displacing all the higher tex units. </p>

</div>
</div>
<a id="a086ffb8324b45010f16fcc6f5314dedd" name="a086ffb8324b45010f16fcc6f5314dedd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a086ffb8324b45010f16fcc6f5314dedd">&#9670;&nbsp;</a></span>removeUavUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::removeUavUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a given texture unit, displacing all the higher tex units. </p>

</div>
</div>
<a id="a27bc9875aa0f3a2f23d7a8c8e3a6e469" name="a27bc9875aa0f3a2f23d7a8c8e3a6e469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27bc9875aa0f3a2f23d7a8c8e3a6e469">&#9670;&nbsp;</a></span>setConstBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setConstBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_const_buffer_packed.html">ConstBufferPacked</a> *&#160;</td>
          <td class="paramname"><em>constBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a const/uniform bufferat the given slot ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slotIdx</td><td>Slot to bind to. It's independent from the texture &amp; UAV ones. </td></tr>
    <tr><td class="paramname">constBuffer</td><td>Const buffer to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29709c020f2dbe9fd7bac1df927f5bc0" name="a29709c020f2dbe9fd7bac1df927f5bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29709c020f2dbe9fd7bac1df927f5bc0">&#9670;&nbsp;</a></span>setGlTexSlotStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setGlTexSlotStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>texSlotStart</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>By default <a class="el" href="class_ogre_1_1_hlms_compute_job.html#ae8398ec1818d61b21005293c32173739" title="Sets a texture buffer at the given slot ID.">HlmsComputeJob::setTexture</a> and <a class="el" href="class_ogre_1_1_hlms_compute_job.html#ab6119b9bf4d187fcbcbb98e0988a09d2" title="Sets a texture buffer at the given slot ID.">HlmsComputeJob::setTexBuffer</a> are in range [0; getNumTexUnits) </p>
<p >However this allows you to offset the range to [texSlotStart; texSlotStart + getNumTexUnits)</p>
<p >This is useful when ReadOnlyBuffers are bound via setTexBuffers, because in OpenGL these will map to uav buffer slots, thus overlapping/conflicting with UAVs </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texSlotStart</td><td>The offset at which the textures/texbuffers should start being bound </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea1aec87cba9ef66ee4b82267de4fb84" name="aea1aec87cba9ef66ee4b82267de4fb84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea1aec87cba9ef66ee4b82267de4fb84">&#9670;&nbsp;</a></span>setInformHlmsOfTextureData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setInformHlmsOfTextureData </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bInformHlms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="class_ogre_1_1_hlms.html" title="HLMS stands for &quot;High Level Material System&quot;.">Hlms</a> has the ability to pass data to the shader source code via its syntax system to add hardcoded values. </p>
<p >For example, you may want to unroll a loop based on the width of a texture for maximum performance. </p><dl class="section user"><dt></dt><dd>Enabling this feature informs the <a class="el" href="class_ogre_1_1_hlms.html" title="HLMS stands for &quot;High Level Material System&quot;.">Hlms</a> to reparse the shader on any change to bound textures that could trigger a recompilation. If you don't need it, keep this feature disabled to prevent unnecessary recompilations. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bInformHlms</td><td>True to enable this feature, false to disable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20e88e59682a6c89874f6c19b1aa89f9" name="a20e88e59682a6c89874f6c19b1aa89f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20e88e59682a6c89874f6c19b1aa89f9">&#9670;&nbsp;</a></span>setNumSamplerUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setNumSamplerUnits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>numSlots</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This value is overriden by setNumTexUnits to be compatible with OpenGL. </p>
<p >However you can later override this behavior to minimize the number of samplers by shrinking (or enlarging?) the sampler units.</p>
<p >This is an advanced function. Don't use it unless you're careful not to assume 1 tex unit = 1 sampler unit </p>

</div>
</div>
<a id="a0998857be120bb37963c7cb593f9bfdc" name="a0998857be120bb37963c7cb593f9bfdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0998857be120bb37963c7cb593f9bfdc">&#9670;&nbsp;</a></span>setNumTexUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setNumTexUnits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>numSlots</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates 'numSlots' number of slots before they can be set. </p>

</div>
</div>
<a id="a80c6b47d60cba7f70ba182d1fc8d9d62" name="a80c6b47d60cba7f70ba182d1fc8d9d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c6b47d60cba7f70ba182d1fc8d9d62">&#9670;&nbsp;</a></span>setNumThreadGroups()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setNumThreadGroups </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>numThreadGroupsX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>numThreadGroupsY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>numThreadGroupsZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the number of groups of threads to dispatch. </p>
<p >Note the actual value may be changed by the shader template using the @pset() function. These values are passed to the template as: num_thread_groups_x num_thread_groups_y num_thread_groups_z </p><dl class="section remark"><dt>Remarks</dt><dd>As an example, it's typical to do: numThreadGroupsX = ceil( threadsPerGroupX / image.width ); numThreadGroupsY = ceil( threadsPerGroupY / image.height ); </dd></dl>
<dl class="section user"><dt></dt><dd>May trigger a recompilation if the value changes, regardless of what setInformHlmsOfTextureData says. There may be API / HW limitations on the max values for each dimension. </dd></dl>

</div>
</div>
<a id="a7ad8078ce6528c5604e2a61bb516c000" name="a7ad8078ce6528c5604e2a61bb516c000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad8078ce6528c5604e2a61bb516c000">&#9670;&nbsp;</a></span>setNumThreadGroupsBasedOn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setNumThreadGroupsBasedOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hlms_compute_job.html#a297b925576b81843bd963d67ec561fbd">ThreadGroupsBasedOn</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>texSlot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>divisorX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>divisorY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>divisorZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instead of calling setNumThreadGroups, <a class="el" href="namespace_ogre.html">Ogre</a> can automatically deduce them based on the <a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource.">Texture</a> resolution and the threads per group. </p>
<p >It is calculated as follows: scaledWidth = (textureWidth + divisorX - 1u) / divisorX; numThreadGroupsX = (scaledWidth + threadsPerGroupX - 1u) / threadsPerGroupX; </p><dl class="section remark"><dt>Remarks</dt><dd>Unless disabled, this will overwrite your setNumThreadGroups based on the texture bound at the time the job is dispatched. </dd></dl>
<dl class="section user"><dt></dt><dd>If no texture/uav is bound at the given slot (or no such slot exists), we will log a warning. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>What to use as source for the calculations. See ThreadGroupsBasedOn </td></tr>
    <tr><td class="paramname">texSlot</td><td>Index of the texture/uav unit. </td></tr>
    <tr><td class="paramname">divisorX</td><td>divisorY divisorZ Often compute shaders operate on multiple pixels, thus you need less thread groups. For example if you operate on blocks of 2x2, then you want divisorX = 2 and divisorY = 2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8697f4897980adba72a42619fe6a463b" name="a8697f4897980adba72a42619fe6a463b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8697f4897980adba72a42619fe6a463b">&#9670;&nbsp;</a></span>setNumUavUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setNumUavUnits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>numSlots</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates 'numSlots' number of slots before they can be set. </p>

</div>
</div>
<a id="adcbb0de211ce8fd2ff8e0d9c869ecf90" name="adcbb0de211ce8fd2ff8e0d9c869ecf90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcbb0de211ce8fd2ff8e0d9c869ecf90">&#9670;&nbsp;</a></span>setPiece()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setPiece </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>pieceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>pieceContent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a piece, i.e. </p>
<p >the same as doing @piece( pieceName )pieceContent@end If the piece doesn't exist, it gets created. If the piece already exists, it gets overwritten. </p><dl class="section remark"><dt>Remarks</dt><dd>Because we need to efficiently track changes (to know when to recompile, when we can reuse a cached shader, etc), we store a property of the same name as pieceName with the hash of the piece's content as value. e.g. doing setPiece( pieceName, pieceContent ) implies calling setProperty( pieceName, hash( pieceContent ). Hence you should NOT manipulate mPieces directly, otherwise we won't see changes performed to it, or use shaders from a cache we shouldn't use. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pieceName</td><td>Name of the piece. </td></tr>
    <tr><td class="paramname">pieceContent</td><td>The contents of the piece. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b558bb23efecb99c9976312caff06c2" name="a7b558bb23efecb99c9976312caff06c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b558bb23efecb99c9976312caff06c2">&#9670;&nbsp;</a></span>setProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ogre_1_1_id_string.html">IdString</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#ae76a40e75ec4ec1c5261cb7d2804ccd3">int32</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an arbitrary property to pass to the shader. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Will trigger a recompilation if the value changes, regardless of what setInformHlmsOfTextureData says. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Name of the property </td></tr>
    <tr><td class="paramname">value</td><td>Value to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a708b1694992ac7ea73e3310fbb9b478b" name="a708b1694992ac7ea73e3310fbb9b478b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a708b1694992ac7ea73e3310fbb9b478b">&#9670;&nbsp;</a></span>setSamplerblock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setSamplerblock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_hlms_samplerblock.html">HlmsSamplerblock</a> &amp;&#160;</td>
          <td class="paramname"><em>refParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a samplerblock based on reference parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slotIdx</td><td>See setNumTexUnits.</td></tr>
  </table>
  </dd>
</dl>
<p>Must be in range [0; getNumTexUnits) regardless of what getTexSlotStart is </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">refParams</td><td>We'll create (or retrieve an existing) samplerblock based on the input parameters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6119b9bf4d187fcbcbb98e0988a09d2" name="ab6119b9bf4d187fcbcbb98e0988a09d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6119b9bf4d187fcbcbb98e0988a09d2">&#9670;&nbsp;</a></span>setTexBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setTexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_descriptor_set_texture2_1_1_buffer_slot.html">DescriptorSetTexture2::BufferSlot</a> &amp;&#160;</td>
          <td class="paramname"><em>newSlot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a texture buffer at the given slot ID. </p>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource.">Texture</a> buffer slots are shared with setTexture's. Calling this function will remove the settings from previous setTexture calls to the same slot index. </dd></dl>
<dl class="section user"><dt></dt><dd>May trigger a recompilation if setInformHlmsOfTextureData is enabled. </dd></dl>
<dl class="section user"><dt></dt><dd>Setting a <a class="el" href="class_ogre_1_1_render_target.html" title="A &#39;canvas&#39; which can receive the results of a rendering operation.">RenderTarget</a> that could be used for writing is dangerous in explicit APIs (DX12, Vulkan). Use the <a class="el" href="class_ogre_1_1_compositor_pass_compute_def.html">CompositorPassComputeDef</a> </dd></dl>
<dl class="section user"><dt></dt><dd><a class="el" href="class_ogre_1_1_read_only_buffer_packed.html" title="Represents the best way to access read-only data.">ReadOnlyBufferPacked</a> can be bound using this function. But please note in certain APIs these type of buffers may end up being bound to UAV slots already taken by _setUav* functions.</dd></dl>
<p>See HlmsComputeJob::setTexSlotStart to workaround that </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slotIdx</td><td>See setNumTexUnits. The slot index to bind this texture buffer In OpenGL, a few cards support between to 16-18 texture units, while most cards support up to 32</td></tr>
  </table>
  </dd>
</dl>
<p>Must be in range [0; getNumTexUnits) regardless of what getTexSlotStart is </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSlot</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8398ec1818d61b21005293c32173739" name="ae8398ec1818d61b21005293c32173739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8398ec1818d61b21005293c32173739">&#9670;&nbsp;</a></span>setTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a9212e2b4c7d29d6fae3a004ac7ad137e">uint8</a>&#160;</td>
          <td class="paramname"><em>slotIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_descriptor_set_texture2_1_1_texture_slot.html">DescriptorSetTexture2::TextureSlot</a> &amp;&#160;</td>
          <td class="paramname"><em>newSlot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_hlms_samplerblock.html">HlmsSamplerblock</a> *&#160;</td>
          <td class="paramname"><em>refParams</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSetSampler</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a texture buffer at the given slot ID. </p>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="class_ogre_1_1_texture.html" title="Abstract class representing a Texture resource.">Texture</a> slots are shared with setTexBuffer's. Calling this function will remove the settings from previous setTexBuffer calls to the same slot index. </dd></dl>
<dl class="section user"><dt></dt><dd>UAVs and Textures share the same slots in OpenGL, but don't in D3D11. For best compatibility, assume they're shared and put the UAVs in the first slots. </dd></dl>
<dl class="section user"><dt></dt><dd>May trigger a recompilation if setInformHlmsOfTextureData is enabled. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slotIdx</td><td>See setNumTexUnits. The slot index to bind this texture In OpenGL, some cards support up to 16-18 texture units, while most cards support up to 32</td></tr>
  </table>
  </dd>
</dl>
<p>Must be in range [0; getNumTexUnits) regardless of what getTexSlotStart is </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">samplerblock</td><td>Optional. We'll create (or retrieve an existing) samplerblock based on the input parameters. When null, we leave the previously set samplerblock (if a texture is being set, and if no samplerblock was set, we'll create a default one) </td></tr>
    <tr><td class="paramname">bSetSampler</td><td>If true, samplerblock will behave as described. When false and samplerblock is nullptr, we won't touch the samplerblock. Only use this with APIs that have separate texturse &amp; sampler (e.g. everyone except GL) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b6c36a6b27927381afeea6965b148b4" name="a1b6c36a6b27927381afeea6965b148b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6c36a6b27927381afeea6965b148b4">&#9670;&nbsp;</a></span>setThreadsPerGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setThreadsPerGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>threadsPerGroupX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>threadsPerGroupY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a5a7c15d68e8c7d585c410bc5a93682f4">uint32</a>&#160;</td>
          <td class="paramname"><em>threadsPerGroupZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the number of threads per group. </p>
<p >Note the actual value may be changed by the shader template using the @pset() function. These values are passed to the template as: threads_per_group_x threads_per_group_y threads_per_group_z </p><dl class="section remark"><dt>Remarks</dt><dd>May trigger a recompilation if the value changes, regardless of what setInformHlmsOfTextureData says. There may be API / HW limitations on the max values for each dimension. </dd></dl>

</div>
</div>
<a id="aa18bf6a908f4f13fc8d0063a88bc0575" name="aa18bf6a908f4f13fc8d0063a88bc0575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18bf6a908f4f13fc8d0063a88bc0575">&#9670;&nbsp;</a></span>setupRootLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::HlmsComputeJob::setupRootLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_root_layout.html">RootLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>rootLayout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1427f0b635a4186cd6083a9bab879fa2" name="a1427f0b635a4186cd6083a9bab879fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1427f0b635a4186cd6083a9bab879fa2">&#9670;&nbsp;</a></span>shouldStayLoaded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::TextureGpuListener::shouldStayLoaded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this <a class="el" href="class_ogre_1_1_texture_gpu.html">TextureGpu</a> should likely stay loaded or else graphical changes could occur. </p>
<p >Return false if it is certainly safe to unload. </p>

<p>Reimplemented in <a class="el" href="group___resources.html#gafcb88d3a6bd52d7f4959f4a20c90e7b2">Ogre::OGRE_HLMS_TEXTURE_BASE_CLASS</a>, and <a class="el" href="class_ogre_1_1_vct_lighting.html#a47f95e656a09ffdb90066b38478ec03c">Ogre::VctLighting</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ae0a13b48d89c085d90419e793aa9c8b9" name="ae0a13b48d89c085d90419e793aa9c8b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a13b48d89c085d90419e793aa9c8b9">&#9670;&nbsp;</a></span>HlmsCompute</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_ogre_1_1_hlms_compute.html">HlmsCompute</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_hlms_compute_job_8h.html">OgreHlmsComputeJob.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_hlms_compute_job.html">HlmsComputeJob</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
